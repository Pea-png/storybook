import JestRunner, { TestRunnerContext, Test, TestWatcher, TestRunnerOptions } from 'jest-runner';
import { Page, Browser, BrowserContext, BrowserContextOptions, LaunchOptions, ConnectOptions, ConnectOverCDPOptions, ViewportSize, BrowserType as BrowserType$1, WebKitBrowser, ChromiumBrowser, FirefoxBrowser, BrowserServer } from 'playwright-core';
import { Config } from '@jest/types';
import { JestProcessManagerOptions } from 'jest-process-manager';

declare const CHROMIUM = "chromium";
declare const FIREFOX = "firefox";
declare const WEBKIT = "webkit";
declare const LAUNCH = "LAUNCH";
declare const PERSISTENT = "PERSISTENT";
declare const SERVER = "SERVER";
type BrowserType = typeof CHROMIUM | typeof FIREFOX | typeof WEBKIT;
type SkipOption = {
    browsers: BrowserType[];
    devices?: string[] | RegExp;
};
interface TestPlaywrightConfigOptions extends JestPlaywrightConfig {
    browser?: BrowserType;
    device?: ConfigDeviceType;
}
type GenericBrowser = BrowserType$1<WebKitBrowser | ChromiumBrowser | FirefoxBrowser>;
type Nullable<T> = T | null;
interface JestPlaywright {
    /**
     * Reset global.page
     *
     * ```ts
     * it('should reset page', async () => {
     *   await jestPlaywright.resetPage()
     * })
     * ```
     */
    resetPage: () => Promise<void>;
    /**
     * Reset global.context
     *
     * ```ts
     * it('should reset context', async () => {
     *   await jestPlaywright.resetContext()
     * })
     * ```
     */
    resetContext: (newOptions?: BrowserContextOptions) => Promise<void>;
    /**
     * Reset global.browser, global.context, and global.page
     *
     * ```ts
     * it('should reset page', async () => {
     *   await jestPlaywright.resetBrowser()
     * })
     * ```
     */
    resetBrowser: (newOptions?: BrowserContextOptions) => Promise<void>;
    /**
     * Saves the coverage to the disk which will only work if `collectCoverage`
     * in `jest-playwright.config.js` file is set to true. The merged coverage file
     * is then available in `.nyc_output/coverage.json`. Mostly its needed in the
     * `afterEach` handler like that:
     *
     * ```ts
     * afterEach(async () => {
     *   await jestPlaywright.saveCoverage(page)
     * })
     * ```
     */
    saveCoverage: (page: Page) => Promise<void>;
    configSeparateEnv: (config: Partial<TestPlaywrightConfigOptions>, isDebug?: boolean) => Promise<ConfigParams>;
}
interface JestParams<T> {
    (options: T, name: string, fn?: jest.ProvidesCallback, timeout?: number): void;
}
type ProvidesCallback = (cb: ConfigParams) => void;
interface JestParamsWithConfigParams<T> {
    (options: Partial<T>, name: string, fn?: ProvidesCallback, timeout?: number): void;
}
interface JestPlaywrightTestDebug extends JestParamsWithConfigParams<JestPlaywrightConfig> {
    (name: string, fn?: ProvidesCallback, timeout?: number): void;
    skip: JestParamsWithConfigParams<JestPlaywrightConfig> | JestPlaywrightTestDebug;
    only: JestParamsWithConfigParams<JestPlaywrightConfig> | JestPlaywrightTestDebug;
}
interface JestPlaywrightTestConfig extends JestParamsWithConfigParams<JestPlaywrightConfig> {
    skip: JestParamsWithConfigParams<JestPlaywrightConfig> | JestPlaywrightTestConfig;
    only: JestParamsWithConfigParams<JestPlaywrightConfig> | JestPlaywrightTestConfig;
}
declare global {
    const browserName: BrowserType;
    const deviceName: Nullable<string>;
    const page: Page;
    const browser: Browser;
    const context: BrowserContext;
    const jestPlaywright: JestPlaywright;
    namespace jest {
        interface It {
            jestPlaywrightSkip: JestParams<SkipOption>;
            jestPlaywrightDebug: JestPlaywrightTestDebug;
            jestPlaywrightConfig: JestPlaywrightTestConfig;
        }
        interface Describe {
            jestPlaywrightSkip: JestParams<SkipOption>;
        }
    }
}
type DeviceDescriptor = {
    viewport: Nullable<ViewportSize>;
    userAgent: string;
    deviceScaleFactor: number;
    isMobile: boolean;
    hasTouch: boolean;
    defaultBrowserType: BrowserType;
};
type CustomDeviceType = Partial<DeviceDescriptor> & {
    name: string;
};
type ConfigDeviceType = CustomDeviceType | string;
type WsEndpointType = Nullable<string>;
type SelectorType = {
    script: string | Function | {
        path?: string;
        content?: string;
    };
    name: string;
};
type LaunchType = typeof LAUNCH | typeof SERVER | typeof PERSISTENT;
type Options<T> = T & Partial<Record<BrowserType, T>>;
type ServerOptions = JestProcessManagerOptions & {
    teardown?: string;
};
interface JestPlaywrightConfig {
    haveSkippedTests?: boolean;
    skipInitialization?: boolean;
    resetContextPerTest?: boolean;
    testTimeout?: number;
    debugOptions?: JestPlaywrightConfig;
    launchType?: LaunchType;
    launchOptions?: Options<LaunchOptions>;
    connectOptions?: Options<(ConnectOptions & {
        wsEndpoint: string;
    }) | ConnectOverCDPOptions>;
    contextOptions?: Options<BrowserContextOptions>;
    userDataDir?: string;
    exitOnPageError?: boolean;
    displayName?: string;
    browsers: (BrowserType | (JestPlaywrightConfig & {
        name: BrowserType;
    }))[];
    devices?: ConfigDeviceType[] | RegExp;
    useDefaultBrowserType?: boolean;
    serverOptions?: ServerOptions | ServerOptions[];
    selectors?: SelectorType[];
    collectCoverage?: boolean;
}
type ConfigParams = {
    browserName: BrowserType;
    deviceName: Nullable<string>;
    browser: Nullable<Browser | BrowserContext>;
    context: BrowserContext;
    page: Page;
};

declare class PlaywrightRunner extends JestRunner {
    browser2Server: Partial<Record<string, BrowserServer>>;
    config: Config.GlobalConfig;
    constructor(globalConfig: Config.GlobalConfig, context: TestRunnerContext);
    launchServer(config: JestPlaywrightConfig, wsEndpoint: WsEndpointType, browser: BrowserType, key: string, instance: GenericBrowser): Promise<WsEndpointType>;
    getTests(tests: Test[], config: JestPlaywrightConfig): Promise<Test[]>;
    runTests(tests: Array<Test>, watcher: TestWatcher, options: TestRunnerOptions): Promise<void>;
}

export { PlaywrightRunner as default };

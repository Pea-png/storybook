import ESM_COMPAT_Module from "node:module";
import { fileURLToPath as ESM_COMPAT_fileURLToPath } from 'node:url';
const __filename = ESM_COMPAT_fileURLToPath(import.meta.url);
const require = ESM_COMPAT_Module.createRequire(import.meta.url);
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/jest-playwright-preset/global.ts
import { setup as setupServer, teardown as teardownServer } from "jest-process-manager";

// src/jest-playwright-preset/utils.ts
import fs from "fs";
import path from "path";

// src/jest-playwright-preset/constants.ts
var CONFIG_ENVIRONMENT_NAME = "jest-playwright";
var CHROMIUM = "chromium";
var SERVER = "SERVER";
var DEFAULT_CONFIG = {
  launchType: SERVER,
  launchOptions: {},
  connectOptions: {},
  contextOptions: {},
  browsers: [
    CHROMIUM
  ],
  exitOnPageError: true,
  collectCoverage: false
};
var DEBUG_TIMEOUT = 4 * 24 * 60 * 60 * 1e3;
var PACKAGE_NAME = "@storybook/test-runner";

// src/jest-playwright-preset/utils.ts
var fsPromises = fs.promises;
var PlaywrightError = class PlaywrightError2 extends Error {
  static {
    __name(this, "PlaywrightError");
  }
  constructor(message) {
    super(formatError(message));
    this.name = "PlaywrightError";
  }
};
var readConfig = /* @__PURE__ */ __name(async (rootDir = process.cwd(), jestEnvConfig) => {
  if (jestEnvConfig) {
    return {
      ...DEFAULT_CONFIG,
      ...jestEnvConfig
    };
  }
  const { JEST_PLAYWRIGHT_CONFIG, npm_package_type } = process.env;
  const fileExtension = npm_package_type === "module" ? "cjs" : "js";
  const configPath = JEST_PLAYWRIGHT_CONFIG || `${CONFIG_ENVIRONMENT_NAME}.config.${fileExtension}`;
  const absConfigPath = path.resolve(rootDir, configPath);
  try {
    await fsPromises.access(absConfigPath);
  } catch (e) {
    if (JEST_PLAYWRIGHT_CONFIG) {
      throw new PlaywrightError(`Can't find a root directory while resolving a config file path.
Provided path to resolve: ${configPath}`);
    } else {
      return DEFAULT_CONFIG;
    }
  }
  const localConfig = await __require(absConfigPath);
  if (typeof localConfig === "function") {
    const config = await localConfig();
    return {
      ...DEFAULT_CONFIG,
      ...config
    };
  }
  return {
    ...DEFAULT_CONFIG,
    ...localConfig
  };
}, "readConfig");
var formatError = /* @__PURE__ */ __name((error) => `${PACKAGE_NAME}: ${error}`, "formatError");

// src/jest-playwright-preset/global.ts
var didAlreadyRunInWatchMode = false;
var ERROR_TIMEOUT = "ERROR_TIMEOUT";
var ERROR_NO_COMMAND = "ERROR_NO_COMMAND";
var logMessage = /* @__PURE__ */ __name(({ message, action }) => {
  console.log("");
  console.error(message);
  console.error(`
\u261D\uFE0F You ${action} in jest-playwright.config.js`);
  process.exit(1);
}, "logMessage");
async function setup(jestConfig) {
  const config = await readConfig(jestConfig.rootDir);
  if (jestConfig.watch || jestConfig.watchAll) {
    if (didAlreadyRunInWatchMode) return;
    didAlreadyRunInWatchMode = true;
  }
  if (config.serverOptions) {
    try {
      await setupServer(config.serverOptions);
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      if (error.code === ERROR_TIMEOUT) {
        logMessage({
          message: error.message,
          action: 'can set "serverOptions.launchTimeout"'
        });
      }
      if (error.code === ERROR_NO_COMMAND) {
        logMessage({
          message: error.message,
          action: 'must set "serverOptions.command"'
        });
      }
      throw error;
    }
  }
}
__name(setup, "setup");

// src/jest-playwright-entries/setup.ts
var setup_default = setup;
export {
  setup_default as default
};

{"ast":null,"code":"import { mapValues } from \"./chunk-AIOS4NGK.js\";\nimport { isPlainObject } from \"./chunk-GFLS4VP3.js\";\nimport { __commonJS, __toESM } from \"./chunk-A242L54C.js\";\n\n// ../node_modules/jsdoc-type-pratt-parser/dist/index.js\nvar require_dist = __commonJS({\n  \"../node_modules/jsdoc-type-pratt-parser/dist/index.js\"(exports, module) {\n    (function (global, factory) {\n      typeof exports == \"object\" && typeof module < \"u\" ? factory(exports) : typeof define == \"function\" && define.amd ? define([\"exports\"], factory) : (global = typeof globalThis < \"u\" ? globalThis : global || self, factory(global.jtpp = {}));\n    })(exports, function (exports2) {\n      \"use strict\";\n\n      function tokenToString(token) {\n        return token.text !== void 0 && token.text !== \"\" ? `'${token.type}' with value '${token.text}'` : `'${token.type}'`;\n      }\n      class NoParsletFoundError extends Error {\n        constructor(token) {\n          super(`No parslet found for token: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, NoParsletFoundError.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      }\n      class EarlyEndOfParseError extends Error {\n        constructor(token) {\n          super(`The parsing ended early. The next token was: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      }\n      class UnexpectedTypeError extends Error {\n        constructor(result, message) {\n          let error = `Unexpected type: '${result.type}'.`;\n          message !== void 0 && (error += ` Message: ${message}`), super(error), Object.setPrototypeOf(this, UnexpectedTypeError.prototype);\n        }\n      }\n      function makePunctuationRule(type) {\n        return text => text.startsWith(type) ? {\n          type,\n          text: type\n        } : null;\n      }\n      function getQuoted(text) {\n        let position = 0,\n          char,\n          mark = text[0],\n          escaped = !1;\n        if (mark !== \"'\" && mark !== '\"') return null;\n        for (; position < text.length;) {\n          if (position++, char = text[position], !escaped && char === mark) {\n            position++;\n            break;\n          }\n          escaped = !escaped && char === \"\\\\\";\n        }\n        if (char !== mark) throw new Error(\"Unterminated String\");\n        return text.slice(0, position);\n      }\n      let identifierStartRegex = new RegExp(\"[$_\\\\p{ID_Start}]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\"),\n        identifierContinueRegex = new RegExp(\"[$\\\\-\\\\p{ID_Continue}\\\\u200C\\\\u200D]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\");\n      function getIdentifier(text) {\n        let char = text[0];\n        if (!identifierStartRegex.test(char)) return null;\n        let position = 1;\n        do {\n          if (char = text[position], !identifierContinueRegex.test(char)) break;\n          position++;\n        } while (position < text.length);\n        return text.slice(0, position);\n      }\n      let numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n      function getNumber(text) {\n        var _a, _b;\n        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n      }\n      let identifierRule = text => {\n        let value = getIdentifier(text);\n        return value == null ? null : {\n          type: \"Identifier\",\n          text: value\n        };\n      };\n      function makeKeyWordRule(type) {\n        return text => {\n          if (!text.startsWith(type)) return null;\n          let prepends = text[type.length];\n          return prepends !== void 0 && identifierContinueRegex.test(prepends) ? null : {\n            type,\n            text: type\n          };\n        };\n      }\n      let stringValueRule = text => {\n          let value = getQuoted(text);\n          return value == null ? null : {\n            type: \"StringValue\",\n            text: value\n          };\n        },\n        eofRule = text => text.length > 0 ? null : {\n          type: \"EOF\",\n          text: \"\"\n        },\n        numberRule = text => {\n          let value = getNumber(text);\n          return value === null ? null : {\n            type: \"Number\",\n            text: value\n          };\n        },\n        rules = [eofRule, makePunctuationRule(\"=>\"), makePunctuationRule(\"(\"), makePunctuationRule(\")\"), makePunctuationRule(\"{\"), makePunctuationRule(\"}\"), makePunctuationRule(\"[\"), makePunctuationRule(\"]\"), makePunctuationRule(\"|\"), makePunctuationRule(\"&\"), makePunctuationRule(\"<\"), makePunctuationRule(\">\"), makePunctuationRule(\",\"), makePunctuationRule(\";\"), makePunctuationRule(\"*\"), makePunctuationRule(\"?\"), makePunctuationRule(\"!\"), makePunctuationRule(\"=\"), makePunctuationRule(\":\"), makePunctuationRule(\"...\"), makePunctuationRule(\".\"), makePunctuationRule(\"#\"), makePunctuationRule(\"~\"), makePunctuationRule(\"/\"), makePunctuationRule(\"@\"), makeKeyWordRule(\"undefined\"), makeKeyWordRule(\"null\"), makeKeyWordRule(\"function\"), makeKeyWordRule(\"this\"), makeKeyWordRule(\"new\"), makeKeyWordRule(\"module\"), makeKeyWordRule(\"event\"), makeKeyWordRule(\"extends\"), makeKeyWordRule(\"external\"), makeKeyWordRule(\"infer\"), makeKeyWordRule(\"typeof\"), makeKeyWordRule(\"keyof\"), makeKeyWordRule(\"readonly\"), makeKeyWordRule(\"import\"), makeKeyWordRule(\"is\"), makeKeyWordRule(\"in\"), makeKeyWordRule(\"asserts\"), numberRule, identifierRule, stringValueRule],\n        breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n      class Lexer {\n        static create(text) {\n          let current = this.read(text);\n          text = current.text;\n          let next = this.read(text);\n          return text = next.text, new Lexer(text, void 0, current.token, next.token);\n        }\n        constructor(text, previous, current, next) {\n          this.text = \"\", this.text = text, this.previous = previous, this.current = current, this.next = next;\n        }\n        static read(text, startOfLine = !1) {\n          startOfLine = startOfLine || breakingWhitespaceRegex.test(text), text = text.trim();\n          for (let rule of rules) {\n            let partial = rule(text);\n            if (partial !== null) {\n              let token = Object.assign(Object.assign({}, partial), {\n                startOfLine\n              });\n              return text = text.slice(token.text.length), {\n                text,\n                token\n              };\n            }\n          }\n          throw new Error(\"Unexpected Token \" + text);\n        }\n        advance() {\n          let next = Lexer.read(this.text);\n          return new Lexer(next.text, this.current, this.next, next.token);\n        }\n      }\n      function assertRootResult(result) {\n        if (result === void 0) throw new Error(\"Unexpected undefined\");\n        if (result.type === \"JsdocTypeKeyValue\" || result.type === \"JsdocTypeParameterList\" || result.type === \"JsdocTypeProperty\" || result.type === \"JsdocTypeReadonlyProperty\" || result.type === \"JsdocTypeObjectField\" || result.type === \"JsdocTypeJsdocObjectField\" || result.type === \"JsdocTypeIndexSignature\" || result.type === \"JsdocTypeMappedType\" || result.type === \"JsdocTypeTypeParameter\") throw new UnexpectedTypeError(result);\n        return result;\n      }\n      function assertPlainKeyValueOrRootResult(result) {\n        return result.type === \"JsdocTypeKeyValue\" ? assertPlainKeyValueResult(result) : assertRootResult(result);\n      }\n      function assertPlainKeyValueOrNameResult(result) {\n        return result.type === \"JsdocTypeName\" ? result : assertPlainKeyValueResult(result);\n      }\n      function assertPlainKeyValueResult(result) {\n        if (result.type !== \"JsdocTypeKeyValue\") throw new UnexpectedTypeError(result);\n        return result;\n      }\n      function assertNumberOrVariadicNameResult(result) {\n        var _a;\n        if (result.type === \"JsdocTypeVariadic\") {\n          if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === \"JsdocTypeName\") return result;\n          throw new UnexpectedTypeError(result);\n        }\n        if (result.type !== \"JsdocTypeNumber\" && result.type !== \"JsdocTypeName\") throw new UnexpectedTypeError(result);\n        return result;\n      }\n      function assertArrayOrTupleResult(result) {\n        if (result.type === \"JsdocTypeTuple\" || result.type === \"JsdocTypeGeneric\" && result.meta.brackets === \"square\") return result;\n        throw new UnexpectedTypeError(result);\n      }\n      function isSquaredProperty(result) {\n        return result.type === \"JsdocTypeIndexSignature\" || result.type === \"JsdocTypeMappedType\";\n      }\n      var Precedence;\n      (function (Precedence2) {\n        Precedence2[Precedence2.ALL = 0] = \"ALL\", Precedence2[Precedence2.PARAMETER_LIST = 1] = \"PARAMETER_LIST\", Precedence2[Precedence2.OBJECT = 2] = \"OBJECT\", Precedence2[Precedence2.KEY_VALUE = 3] = \"KEY_VALUE\", Precedence2[Precedence2.INDEX_BRACKETS = 4] = \"INDEX_BRACKETS\", Precedence2[Precedence2.UNION = 5] = \"UNION\", Precedence2[Precedence2.INTERSECTION = 6] = \"INTERSECTION\", Precedence2[Precedence2.PREFIX = 7] = \"PREFIX\", Precedence2[Precedence2.INFIX = 8] = \"INFIX\", Precedence2[Precedence2.TUPLE = 9] = \"TUPLE\", Precedence2[Precedence2.SYMBOL = 10] = \"SYMBOL\", Precedence2[Precedence2.OPTIONAL = 11] = \"OPTIONAL\", Precedence2[Precedence2.NULLABLE = 12] = \"NULLABLE\", Precedence2[Precedence2.KEY_OF_TYPE_OF = 13] = \"KEY_OF_TYPE_OF\", Precedence2[Precedence2.FUNCTION = 14] = \"FUNCTION\", Precedence2[Precedence2.ARROW = 15] = \"ARROW\", Precedence2[Precedence2.ARRAY_BRACKETS = 16] = \"ARRAY_BRACKETS\", Precedence2[Precedence2.GENERIC = 17] = \"GENERIC\", Precedence2[Precedence2.NAME_PATH = 18] = \"NAME_PATH\", Precedence2[Precedence2.PARENTHESIS = 19] = \"PARENTHESIS\", Precedence2[Precedence2.SPECIAL_TYPES = 20] = \"SPECIAL_TYPES\";\n      })(Precedence || (Precedence = {}));\n      class Parser {\n        constructor(grammar, textOrLexer, baseParser) {\n          this.grammar = grammar, typeof textOrLexer == \"string\" ? this._lexer = Lexer.create(textOrLexer) : this._lexer = textOrLexer, this.baseParser = baseParser;\n        }\n        get lexer() {\n          return this._lexer;\n        }\n        /**\n         * Parses a given string and throws an error if the parse ended before the end of the string.\n         */\n        parse() {\n          let result = this.parseType(Precedence.ALL);\n          if (this.lexer.current.type !== \"EOF\") throw new EarlyEndOfParseError(this.lexer.current);\n          return result;\n        }\n        /**\n         * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n         */\n        parseType(precedence) {\n          return assertRootResult(this.parseIntermediateType(precedence));\n        }\n        /**\n         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n         * to parse the state in the infix step.\n         */\n        parseIntermediateType(precedence) {\n          let result = this.tryParslets(null, precedence);\n          if (result === null) throw new NoParsletFoundError(this.lexer.current);\n          return this.parseInfixIntermediateType(result, precedence);\n        }\n        /**\n         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n         * a result.\n         */\n        parseInfixIntermediateType(left, precedence) {\n          let result = this.tryParslets(left, precedence);\n          for (; result !== null;) left = result, result = this.tryParslets(left, precedence);\n          return left;\n        }\n        /**\n         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n         */\n        tryParslets(left, precedence) {\n          for (let parslet of this.grammar) {\n            let result = parslet(this, precedence, left);\n            if (result !== null) return result;\n          }\n          return null;\n        }\n        /**\n         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n         * advanced.\n         */\n        consume(types) {\n          return Array.isArray(types) || (types = [types]), types.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), !0) : !1;\n        }\n        acceptLexerState(parser) {\n          this._lexer = parser.lexer;\n        }\n      }\n      function isQuestionMarkUnknownType(next) {\n        return next === \"}\" || next === \"EOF\" || next === \"|\" || next === \",\" || next === \")\" || next === \">\";\n      }\n      let nullableParslet = (parser, precedence, left) => {\n        let type = parser.lexer.current.type,\n          next = parser.lexer.next.type;\n        return left == null && type === \"?\" && !isQuestionMarkUnknownType(next) || left != null && type === \"?\" ? (parser.consume(\"?\"), left == null ? {\n          type: \"JsdocTypeNullable\",\n          element: parser.parseType(Precedence.NULLABLE),\n          meta: {\n            position: \"prefix\"\n          }\n        } : {\n          type: \"JsdocTypeNullable\",\n          element: assertRootResult(left),\n          meta: {\n            position: \"suffix\"\n          }\n        }) : null;\n      };\n      function composeParslet(options) {\n        let parslet = (parser, curPrecedence, left) => {\n          let type = parser.lexer.current.type,\n            next = parser.lexer.next.type;\n          if (left === null) {\n            if (\"parsePrefix\" in options && options.accept(type, next)) return options.parsePrefix(parser);\n          } else if (\"parseInfix\" in options && options.precedence > curPrecedence && options.accept(type, next)) return options.parseInfix(parser, left);\n          return null;\n        };\n        return Object.defineProperty(parslet, \"name\", {\n          value: options.name\n        }), parslet;\n      }\n      let optionalParslet = composeParslet({\n          name: \"optionalParslet\",\n          accept: type => type === \"=\",\n          precedence: Precedence.OPTIONAL,\n          parsePrefix: parser => (parser.consume(\"=\"), {\n            type: \"JsdocTypeOptional\",\n            element: parser.parseType(Precedence.OPTIONAL),\n            meta: {\n              position: \"prefix\"\n            }\n          }),\n          parseInfix: (parser, left) => (parser.consume(\"=\"), {\n            type: \"JsdocTypeOptional\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\"\n            }\n          })\n        }),\n        numberParslet = composeParslet({\n          name: \"numberParslet\",\n          accept: type => type === \"Number\",\n          parsePrefix: parser => {\n            let value = parseFloat(parser.lexer.current.text);\n            return parser.consume(\"Number\"), {\n              type: \"JsdocTypeNumber\",\n              value\n            };\n          }\n        }),\n        parenthesisParslet = composeParslet({\n          name: \"parenthesisParslet\",\n          accept: type => type === \"(\",\n          parsePrefix: parser => {\n            if (parser.consume(\"(\"), parser.consume(\")\")) return {\n              type: \"JsdocTypeParameterList\",\n              elements: []\n            };\n            let result = parser.parseIntermediateType(Precedence.ALL);\n            if (!parser.consume(\")\")) throw new Error(\"Unterminated parenthesis\");\n            return result.type === \"JsdocTypeParameterList\" ? result : result.type === \"JsdocTypeKeyValue\" ? {\n              type: \"JsdocTypeParameterList\",\n              elements: [result]\n            } : {\n              type: \"JsdocTypeParenthesis\",\n              element: assertRootResult(result)\n            };\n          }\n        }),\n        specialTypesParslet = composeParslet({\n          name: \"specialTypesParslet\",\n          accept: (type, next) => type === \"?\" && isQuestionMarkUnknownType(next) || type === \"null\" || type === \"undefined\" || type === \"*\",\n          parsePrefix: parser => {\n            if (parser.consume(\"null\")) return {\n              type: \"JsdocTypeNull\"\n            };\n            if (parser.consume(\"undefined\")) return {\n              type: \"JsdocTypeUndefined\"\n            };\n            if (parser.consume(\"*\")) return {\n              type: \"JsdocTypeAny\"\n            };\n            if (parser.consume(\"?\")) return {\n              type: \"JsdocTypeUnknown\"\n            };\n            throw new Error(\"Unacceptable token: \" + parser.lexer.current.text);\n          }\n        }),\n        notNullableParslet = composeParslet({\n          name: \"notNullableParslet\",\n          accept: type => type === \"!\",\n          precedence: Precedence.NULLABLE,\n          parsePrefix: parser => (parser.consume(\"!\"), {\n            type: \"JsdocTypeNotNullable\",\n            element: parser.parseType(Precedence.NULLABLE),\n            meta: {\n              position: \"prefix\"\n            }\n          }),\n          parseInfix: (parser, left) => (parser.consume(\"!\"), {\n            type: \"JsdocTypeNotNullable\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\"\n            }\n          })\n        });\n      function createParameterListParslet({\n        allowTrailingComma\n      }) {\n        return composeParslet({\n          name: \"parameterListParslet\",\n          accept: type => type === \",\",\n          precedence: Precedence.PARAMETER_LIST,\n          parseInfix: (parser, left) => {\n            let elements = [assertPlainKeyValueOrRootResult(left)];\n            parser.consume(\",\");\n            do try {\n              let next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n              elements.push(assertPlainKeyValueOrRootResult(next));\n            } catch (e) {\n              if (e instanceof NoParsletFoundError) break;\n              throw e;\n            } while (parser.consume(\",\"));\n            if (elements.length > 0 && elements.slice(0, -1).some(e => e.type === \"JsdocTypeVariadic\")) throw new Error(\"Only the last parameter may be a rest parameter\");\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements\n            };\n          }\n        });\n      }\n      let genericParslet = composeParslet({\n          name: \"genericParslet\",\n          accept: (type, next) => type === \"<\" || type === \".\" && next === \"<\",\n          precedence: Precedence.GENERIC,\n          parseInfix: (parser, left) => {\n            let dot = parser.consume(\".\");\n            parser.consume(\"<\");\n            let objects = [],\n              infer = !1;\n            if (parser.consume(\"infer\")) {\n              infer = !0;\n              let left2 = parser.parseIntermediateType(Precedence.SYMBOL);\n              if (left2.type !== \"JsdocTypeName\") throw new UnexpectedTypeError(left2, \"A typescript asserts always has to have a name on the left side.\");\n              objects.push(left2);\n            } else do objects.push(parser.parseType(Precedence.PARAMETER_LIST)); while (parser.consume(\",\"));\n            if (!parser.consume(\">\")) throw new Error(\"Unterminated generic parameter list\");\n            return Object.assign(Object.assign({\n              type: \"JsdocTypeGeneric\",\n              left: assertRootResult(left),\n              elements: objects\n            }, infer ? {\n              infer: !0\n            } : {}), {\n              meta: {\n                brackets: \"angle\",\n                dot\n              }\n            });\n          }\n        }),\n        unionParslet = composeParslet({\n          name: \"unionParslet\",\n          accept: type => type === \"|\",\n          precedence: Precedence.UNION,\n          parseInfix: (parser, left) => {\n            parser.consume(\"|\");\n            let elements = [];\n            do elements.push(parser.parseType(Precedence.UNION)); while (parser.consume(\"|\"));\n            return {\n              type: \"JsdocTypeUnion\",\n              elements: [assertRootResult(left), ...elements]\n            };\n          }\n        }),\n        baseGrammar = [nullableParslet, optionalParslet, numberParslet, parenthesisParslet, specialTypesParslet, notNullableParslet, createParameterListParslet({\n          allowTrailingComma: !0\n        }), genericParslet, unionParslet, optionalParslet];\n      function createNamePathParslet({\n        allowSquareBracketsOnAnyType,\n        allowJsdocNamePaths,\n        pathGrammar: pathGrammar2\n      }) {\n        return function (parser, precedence, left) {\n          if (left == null || precedence >= Precedence.NAME_PATH) return null;\n          let type = parser.lexer.current.type,\n            next = parser.lexer.next.type;\n          if (!(type === \".\" && next !== \"<\" || type === \"[\" && (allowSquareBracketsOnAnyType || left.type === \"JsdocTypeName\") || allowJsdocNamePaths && (type === \"~\" || type === \"#\"))) return null;\n          let pathType,\n            brackets = !1;\n          parser.consume(\".\") ? pathType = \"property\" : parser.consume(\"[\") ? (pathType = \"property-brackets\", brackets = !0) : parser.consume(\"~\") ? pathType = \"inner\" : (parser.consume(\"#\"), pathType = \"instance\");\n          let pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser,\n            parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n          parser.acceptLexerState(pathParser);\n          let right;\n          switch (parsed.type) {\n            case \"JsdocTypeName\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value,\n                meta: {\n                  quote: void 0\n                }\n              };\n              break;\n            case \"JsdocTypeNumber\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value.toString(10),\n                meta: {\n                  quote: void 0\n                }\n              };\n              break;\n            case \"JsdocTypeStringValue\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value,\n                meta: {\n                  quote: parsed.meta.quote\n                }\n              };\n              break;\n            case \"JsdocTypeSpecialNamePath\":\n              if (parsed.specialType === \"event\") right = parsed;else throw new UnexpectedTypeError(parsed, \"Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'\");\n              break;\n            default:\n              throw new UnexpectedTypeError(parsed, \"Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'\");\n          }\n          if (brackets && !parser.consume(\"]\")) {\n            let token = parser.lexer.current;\n            throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);\n          }\n          return {\n            type: \"JsdocTypeNamePath\",\n            left: assertRootResult(left),\n            right,\n            pathType\n          };\n        };\n      }\n      function createNameParslet({\n        allowedAdditionalTokens\n      }) {\n        return composeParslet({\n          name: \"nameParslet\",\n          accept: type => type === \"Identifier\" || type === \"this\" || type === \"new\" || allowedAdditionalTokens.includes(type),\n          parsePrefix: parser => {\n            let {\n              type,\n              text\n            } = parser.lexer.current;\n            return parser.consume(type), {\n              type: \"JsdocTypeName\",\n              value: text\n            };\n          }\n        });\n      }\n      let stringValueParslet = composeParslet({\n        name: \"stringValueParslet\",\n        accept: type => type === \"StringValue\",\n        parsePrefix: parser => {\n          let text = parser.lexer.current.text;\n          return parser.consume(\"StringValue\"), {\n            type: \"JsdocTypeStringValue\",\n            value: text.slice(1, -1),\n            meta: {\n              quote: text[0] === \"'\" ? \"single\" : \"double\"\n            }\n          };\n        }\n      });\n      function createSpecialNamePathParslet({\n        pathGrammar: pathGrammar2,\n        allowedTypes\n      }) {\n        return composeParslet({\n          name: \"specialNamePathParslet\",\n          accept: type => allowedTypes.includes(type),\n          parsePrefix: parser => {\n            let type = parser.lexer.current.type;\n            if (parser.consume(type), !parser.consume(\":\")) return {\n              type: \"JsdocTypeName\",\n              value: type\n            };\n            let result,\n              token = parser.lexer.current;\n            if (parser.consume(\"StringValue\")) result = {\n              type: \"JsdocTypeSpecialNamePath\",\n              value: token.text.slice(1, -1),\n              specialType: type,\n              meta: {\n                quote: token.text[0] === \"'\" ? \"single\" : \"double\"\n              }\n            };else {\n              let value = \"\",\n                allowed = [\"Identifier\", \"@\", \"/\"];\n              for (; allowed.some(type2 => parser.consume(type2));) value += token.text, token = parser.lexer.current;\n              result = {\n                type: \"JsdocTypeSpecialNamePath\",\n                value,\n                specialType: type,\n                meta: {\n                  quote: void 0\n                }\n              };\n            }\n            let moduleParser = new Parser(pathGrammar2, parser.lexer, parser),\n              moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n            return parser.acceptLexerState(moduleParser), assertRootResult(moduleResult);\n          }\n        });\n      }\n      let basePathGrammar = [createNameParslet({\n          allowedAdditionalTokens: [\"external\", \"module\"]\n        }), stringValueParslet, numberParslet, createNamePathParslet({\n          allowSquareBracketsOnAnyType: !1,\n          allowJsdocNamePaths: !0,\n          pathGrammar: null\n        })],\n        pathGrammar = [...basePathGrammar, createSpecialNamePathParslet({\n          allowedTypes: [\"event\"],\n          pathGrammar: basePathGrammar\n        })];\n      function getParameters(value) {\n        let parameters;\n        if (value.type === \"JsdocTypeParameterList\") parameters = value.elements;else if (value.type === \"JsdocTypeParenthesis\") parameters = [value.element];else throw new UnexpectedTypeError(value);\n        return parameters.map(p => assertPlainKeyValueOrRootResult(p));\n      }\n      function getUnnamedParameters(value) {\n        let parameters = getParameters(value);\n        if (parameters.some(p => p.type === \"JsdocTypeKeyValue\")) throw new Error(\"No parameter should be named\");\n        return parameters;\n      }\n      function createFunctionParslet({\n        allowNamedParameters,\n        allowNoReturnType,\n        allowWithoutParenthesis,\n        allowNewAsFunctionKeyword\n      }) {\n        return composeParslet({\n          name: \"functionParslet\",\n          accept: (type, next) => type === \"function\" || allowNewAsFunctionKeyword && type === \"new\" && next === \"(\",\n          parsePrefix: parser => {\n            let newKeyword = parser.consume(\"new\");\n            parser.consume(\"function\");\n            let hasParenthesis = parser.lexer.current.type === \"(\";\n            if (!hasParenthesis) {\n              if (!allowWithoutParenthesis) throw new Error(\"function is missing parameter list\");\n              return {\n                type: \"JsdocTypeName\",\n                value: \"function\"\n              };\n            }\n            let result = {\n                type: \"JsdocTypeFunction\",\n                parameters: [],\n                arrow: !1,\n                constructor: newKeyword,\n                parenthesis: hasParenthesis\n              },\n              value = parser.parseIntermediateType(Precedence.FUNCTION);\n            if (allowNamedParameters === void 0) result.parameters = getUnnamedParameters(value);else {\n              if (newKeyword && value.type === \"JsdocTypeFunction\" && value.arrow) return result = value, result.constructor = !0, result;\n              result.parameters = getParameters(value);\n              for (let p of result.parameters) if (p.type === \"JsdocTypeKeyValue\" && !allowNamedParameters.includes(p.key)) throw new Error(`only allowed named parameters are ${allowNamedParameters.join(\", \")} but got ${p.type}`);\n            }\n            if (parser.consume(\":\")) result.returnType = parser.parseType(Precedence.PREFIX);else if (!allowNoReturnType) throw new Error(\"function is missing return type\");\n            return result;\n          }\n        });\n      }\n      function createVariadicParslet({\n        allowPostfix,\n        allowEnclosingBrackets\n      }) {\n        return composeParslet({\n          name: \"variadicParslet\",\n          accept: type => type === \"...\",\n          precedence: Precedence.PREFIX,\n          parsePrefix: parser => {\n            parser.consume(\"...\");\n            let brackets = allowEnclosingBrackets && parser.consume(\"[\");\n            try {\n              let element = parser.parseType(Precedence.PREFIX);\n              if (brackets && !parser.consume(\"]\")) throw new Error(\"Unterminated variadic type. Missing ']'\");\n              return {\n                type: \"JsdocTypeVariadic\",\n                element: assertRootResult(element),\n                meta: {\n                  position: \"prefix\",\n                  squareBrackets: brackets\n                }\n              };\n            } catch (e) {\n              if (e instanceof NoParsletFoundError) {\n                if (brackets) throw new Error(\"Empty square brackets for variadic are not allowed.\");\n                return {\n                  type: \"JsdocTypeVariadic\",\n                  meta: {\n                    position: void 0,\n                    squareBrackets: !1\n                  }\n                };\n              } else throw e;\n            }\n          },\n          parseInfix: allowPostfix ? (parser, left) => (parser.consume(\"...\"), {\n            type: \"JsdocTypeVariadic\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\",\n              squareBrackets: !1\n            }\n          }) : void 0\n        });\n      }\n      let symbolParslet = composeParslet({\n          name: \"symbolParslet\",\n          accept: type => type === \"(\",\n          precedence: Precedence.SYMBOL,\n          parseInfix: (parser, left) => {\n            if (left.type !== \"JsdocTypeName\") throw new Error(\"Symbol expects a name on the left side. (Reacting on '(')\");\n            parser.consume(\"(\");\n            let result = {\n              type: \"JsdocTypeSymbol\",\n              value: left.value\n            };\n            if (!parser.consume(\")\")) {\n              let next = parser.parseIntermediateType(Precedence.SYMBOL);\n              if (result.element = assertNumberOrVariadicNameResult(next), !parser.consume(\")\")) throw new Error(\"Symbol does not end after value\");\n            }\n            return result;\n          }\n        }),\n        arrayBracketsParslet = composeParslet({\n          name: \"arrayBracketsParslet\",\n          precedence: Precedence.ARRAY_BRACKETS,\n          accept: (type, next) => type === \"[\" && next === \"]\",\n          parseInfix: (parser, left) => (parser.consume(\"[\"), parser.consume(\"]\"), {\n            type: \"JsdocTypeGeneric\",\n            left: {\n              type: \"JsdocTypeName\",\n              value: \"Array\"\n            },\n            elements: [assertRootResult(left)],\n            meta: {\n              brackets: \"square\",\n              dot: !1\n            }\n          })\n        });\n      function createObjectParslet({\n        objectFieldGrammar: objectFieldGrammar2,\n        allowKeyTypes\n      }) {\n        return composeParslet({\n          name: \"objectParslet\",\n          accept: type => type === \"{\",\n          parsePrefix: parser => {\n            parser.consume(\"{\");\n            let result = {\n              type: \"JsdocTypeObject\",\n              meta: {\n                separator: \"comma\"\n              },\n              elements: []\n            };\n            if (!parser.consume(\"}\")) {\n              let separator,\n                fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);\n              for (;;) {\n                fieldParser.acceptLexerState(parser);\n                let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n                parser.acceptLexerState(fieldParser), field === void 0 && allowKeyTypes && (field = parser.parseIntermediateType(Precedence.OBJECT));\n                let optional = !1;\n                if (field.type === \"JsdocTypeNullable\" && (optional = !0, field = field.element), field.type === \"JsdocTypeNumber\" || field.type === \"JsdocTypeName\" || field.type === \"JsdocTypeStringValue\") {\n                  let quote2;\n                  field.type === \"JsdocTypeStringValue\" && (quote2 = field.meta.quote), result.elements.push({\n                    type: \"JsdocTypeObjectField\",\n                    key: field.value.toString(),\n                    right: void 0,\n                    optional,\n                    readonly: !1,\n                    meta: {\n                      quote: quote2\n                    }\n                  });\n                } else if (field.type === \"JsdocTypeObjectField\" || field.type === \"JsdocTypeJsdocObjectField\") result.elements.push(field);else throw new UnexpectedTypeError(field);\n                if (parser.lexer.current.startOfLine) separator = \"linebreak\", parser.consume(\",\") || parser.consume(\";\");else if (parser.consume(\",\")) separator = \"comma\";else if (parser.consume(\";\")) separator = \"semicolon\";else break;\n                if (parser.lexer.current.type === \"}\") break;\n              }\n              if (result.meta.separator = separator ?? \"comma\", separator === \"linebreak\" && (result.meta.propertyIndent = \"  \"), !parser.consume(\"}\")) throw new Error(\"Unterminated record type. Missing '}'\");\n            }\n            return result;\n          }\n        });\n      }\n      function createObjectFieldParslet({\n        allowSquaredProperties,\n        allowKeyTypes,\n        allowReadonly,\n        allowOptional\n      }) {\n        return composeParslet({\n          name: \"objectFieldParslet\",\n          precedence: Precedence.KEY_VALUE,\n          accept: type => type === \":\",\n          parseInfix: (parser, left) => {\n            var _a;\n            let optional = !1,\n              readonlyProperty = !1;\n            allowOptional && left.type === \"JsdocTypeNullable\" && (optional = !0, left = left.element), allowReadonly && left.type === \"JsdocTypeReadonlyProperty\" && (readonlyProperty = !0, left = left.element);\n            let parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n            if (parentParser.acceptLexerState(parser), left.type === \"JsdocTypeNumber\" || left.type === \"JsdocTypeName\" || left.type === \"JsdocTypeStringValue\" || isSquaredProperty(left)) {\n              if (isSquaredProperty(left) && !allowSquaredProperties) throw new UnexpectedTypeError(left);\n              parentParser.consume(\":\");\n              let quote2;\n              left.type === \"JsdocTypeStringValue\" && (quote2 = left.meta.quote);\n              let right = parentParser.parseType(Precedence.KEY_VALUE);\n              return parser.acceptLexerState(parentParser), {\n                type: \"JsdocTypeObjectField\",\n                key: isSquaredProperty(left) ? left : left.value.toString(),\n                right,\n                optional,\n                readonly: readonlyProperty,\n                meta: {\n                  quote: quote2\n                }\n              };\n            } else {\n              if (!allowKeyTypes) throw new UnexpectedTypeError(left);\n              parentParser.consume(\":\");\n              let right = parentParser.parseType(Precedence.KEY_VALUE);\n              return parser.acceptLexerState(parentParser), {\n                type: \"JsdocTypeJsdocObjectField\",\n                left: assertRootResult(left),\n                right\n              };\n            }\n          }\n        });\n      }\n      function createKeyValueParslet({\n        allowOptional,\n        allowVariadic\n      }) {\n        return composeParslet({\n          name: \"keyValueParslet\",\n          precedence: Precedence.KEY_VALUE,\n          accept: type => type === \":\",\n          parseInfix: (parser, left) => {\n            let optional = !1,\n              variadic = !1;\n            if (allowOptional && left.type === \"JsdocTypeNullable\" && (optional = !0, left = left.element), allowVariadic && left.type === \"JsdocTypeVariadic\" && left.element !== void 0 && (variadic = !0, left = left.element), left.type !== \"JsdocTypeName\") throw new UnexpectedTypeError(left);\n            parser.consume(\":\");\n            let right = parser.parseType(Precedence.KEY_VALUE);\n            return {\n              type: \"JsdocTypeKeyValue\",\n              key: left.value,\n              right,\n              optional,\n              variadic\n            };\n          }\n        });\n      }\n      let jsdocBaseGrammar = [...baseGrammar, createFunctionParslet({\n          allowWithoutParenthesis: !0,\n          allowNamedParameters: [\"this\", \"new\"],\n          allowNoReturnType: !0,\n          allowNewAsFunctionKeyword: !1\n        }), stringValueParslet, createSpecialNamePathParslet({\n          allowedTypes: [\"module\", \"external\", \"event\"],\n          pathGrammar\n        }), createVariadicParslet({\n          allowEnclosingBrackets: !0,\n          allowPostfix: !0\n        }), createNameParslet({\n          allowedAdditionalTokens: [\"keyof\"]\n        }), symbolParslet, arrayBracketsParslet, createNamePathParslet({\n          allowSquareBracketsOnAnyType: !1,\n          allowJsdocNamePaths: !0,\n          pathGrammar\n        })],\n        jsdocGrammar = [...jsdocBaseGrammar, createObjectParslet({\n          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n          // we leave out the object type deliberately\n          objectFieldGrammar: [createNameParslet({\n            allowedAdditionalTokens: [\"typeof\", \"module\", \"in\"]\n          }), createObjectFieldParslet({\n            allowSquaredProperties: !1,\n            allowKeyTypes: !0,\n            allowOptional: !1,\n            allowReadonly: !1\n          }), ...jsdocBaseGrammar],\n          allowKeyTypes: !0\n        }), createKeyValueParslet({\n          allowOptional: !0,\n          allowVariadic: !0\n        })],\n        typeOfParslet = composeParslet({\n          name: \"typeOfParslet\",\n          accept: type => type === \"typeof\",\n          parsePrefix: parser => (parser.consume(\"typeof\"), {\n            type: \"JsdocTypeTypeof\",\n            element: parser.parseType(Precedence.KEY_OF_TYPE_OF)\n          })\n        }),\n        objectFieldGrammar$1 = [createNameParslet({\n          allowedAdditionalTokens: [\"typeof\", \"module\", \"keyof\", \"event\", \"external\", \"in\"]\n        }), nullableParslet, optionalParslet, stringValueParslet, numberParslet, createObjectFieldParslet({\n          allowSquaredProperties: !1,\n          allowKeyTypes: !1,\n          allowOptional: !1,\n          allowReadonly: !1\n        })],\n        closureGrammar = [...baseGrammar, createObjectParslet({\n          allowKeyTypes: !1,\n          objectFieldGrammar: objectFieldGrammar$1\n        }), createNameParslet({\n          allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n        }), typeOfParslet, createFunctionParslet({\n          allowWithoutParenthesis: !1,\n          allowNamedParameters: [\"this\", \"new\"],\n          allowNoReturnType: !0,\n          allowNewAsFunctionKeyword: !1\n        }), createVariadicParslet({\n          allowEnclosingBrackets: !1,\n          allowPostfix: !1\n        }),\n        // additional name parslet is needed for some special cases\n        createNameParslet({\n          allowedAdditionalTokens: [\"keyof\"]\n        }), createSpecialNamePathParslet({\n          allowedTypes: [\"module\"],\n          pathGrammar\n        }), createNamePathParslet({\n          allowSquareBracketsOnAnyType: !1,\n          allowJsdocNamePaths: !0,\n          pathGrammar\n        }), createKeyValueParslet({\n          allowOptional: !1,\n          allowVariadic: !1\n        }), symbolParslet],\n        assertsParslet = composeParslet({\n          name: \"assertsParslet\",\n          accept: type => type === \"asserts\",\n          parsePrefix: parser => {\n            parser.consume(\"asserts\");\n            let left = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (left.type !== \"JsdocTypeName\") throw new UnexpectedTypeError(left, \"A typescript asserts always has to have a name on the left side.\");\n            return parser.consume(\"is\") ? {\n              type: \"JsdocTypeAsserts\",\n              left,\n              right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n            } : {\n              type: \"JsdocTypeAssertsPlain\",\n              element: left\n            };\n          }\n        });\n      function createTupleParslet({\n        allowQuestionMark\n      }) {\n        return composeParslet({\n          name: \"tupleParslet\",\n          accept: type => type === \"[\",\n          parsePrefix: parser => {\n            parser.consume(\"[\");\n            let result = {\n              type: \"JsdocTypeTuple\",\n              elements: []\n            };\n            if (parser.consume(\"]\")) return result;\n            let typeList = parser.parseIntermediateType(Precedence.ALL);\n            if (typeList.type === \"JsdocTypeParameterList\" ? typeList.elements[0].type === \"JsdocTypeKeyValue\" ? result.elements = typeList.elements.map(assertPlainKeyValueResult) : result.elements = typeList.elements.map(assertRootResult) : typeList.type === \"JsdocTypeKeyValue\" ? result.elements = [assertPlainKeyValueResult(typeList)] : result.elements = [assertRootResult(typeList)], !parser.consume(\"]\")) throw new Error(\"Unterminated '['\");\n            if (result.elements.some(e => e.type === \"JsdocTypeUnknown\")) throw new Error(\"Question mark in tuple not allowed\");\n            return result;\n          }\n        });\n      }\n      let keyOfParslet = composeParslet({\n          name: \"keyOfParslet\",\n          accept: type => type === \"keyof\",\n          parsePrefix: parser => (parser.consume(\"keyof\"), {\n            type: \"JsdocTypeKeyof\",\n            element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n          })\n        }),\n        importParslet = composeParslet({\n          name: \"importParslet\",\n          accept: type => type === \"import\",\n          parsePrefix: parser => {\n            if (parser.consume(\"import\"), !parser.consume(\"(\")) throw new Error(\"Missing parenthesis after import keyword\");\n            let path = parser.parseType(Precedence.PREFIX);\n            if (path.type !== \"JsdocTypeStringValue\") throw new Error(\"Only string values are allowed as paths for imports\");\n            if (!parser.consume(\")\")) throw new Error(\"Missing closing parenthesis after import keyword\");\n            return {\n              type: \"JsdocTypeImport\",\n              element: path\n            };\n          }\n        }),\n        readonlyPropertyParslet = composeParslet({\n          name: \"readonlyPropertyParslet\",\n          accept: type => type === \"readonly\",\n          parsePrefix: parser => (parser.consume(\"readonly\"), {\n            type: \"JsdocTypeReadonlyProperty\",\n            element: parser.parseIntermediateType(Precedence.KEY_VALUE)\n          })\n        }),\n        arrowFunctionParslet = composeParslet({\n          name: \"arrowFunctionParslet\",\n          precedence: Precedence.ARROW,\n          accept: type => type === \"=>\",\n          parseInfix: (parser, left) => (parser.consume(\"=>\"), {\n            type: \"JsdocTypeFunction\",\n            parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n            arrow: !0,\n            constructor: !1,\n            parenthesis: !0,\n            returnType: parser.parseType(Precedence.OBJECT)\n          })\n        }),\n        genericArrowFunctionParslet = composeParslet({\n          name: \"genericArrowFunctionParslet\",\n          accept: type => type === \"<\",\n          parsePrefix: parser => {\n            let typeParameters = [];\n            parser.consume(\"<\");\n            do {\n              let defaultValue,\n                name = parser.parseIntermediateType(Precedence.SYMBOL);\n              if (name.type === \"JsdocTypeOptional\" && (name = name.element, defaultValue = parser.parseType(Precedence.SYMBOL)), name.type !== \"JsdocTypeName\") throw new UnexpectedTypeError(name);\n              let constraint;\n              parser.consume(\"extends\") && (constraint = parser.parseType(Precedence.SYMBOL), constraint.type === \"JsdocTypeOptional\" && (constraint = constraint.element, defaultValue = parser.parseType(Precedence.SYMBOL)));\n              let typeParameter = {\n                type: \"JsdocTypeTypeParameter\",\n                name\n              };\n              if (constraint !== void 0 && (typeParameter.constraint = constraint), defaultValue !== void 0 && (typeParameter.defaultValue = defaultValue), typeParameters.push(typeParameter), parser.consume(\">\")) break;\n            } while (parser.consume(\",\"));\n            let functionBase = parser.parseIntermediateType(Precedence.SYMBOL);\n            return functionBase.typeParameters = typeParameters, functionBase;\n          }\n        }),\n        intersectionParslet = composeParslet({\n          name: \"intersectionParslet\",\n          accept: type => type === \"&\",\n          precedence: Precedence.INTERSECTION,\n          parseInfix: (parser, left) => {\n            parser.consume(\"&\");\n            let elements = [];\n            do elements.push(parser.parseType(Precedence.INTERSECTION)); while (parser.consume(\"&\"));\n            return {\n              type: \"JsdocTypeIntersection\",\n              elements: [assertRootResult(left), ...elements]\n            };\n          }\n        }),\n        predicateParslet = composeParslet({\n          name: \"predicateParslet\",\n          precedence: Precedence.INFIX,\n          accept: type => type === \"is\",\n          parseInfix: (parser, left) => {\n            if (left.type !== \"JsdocTypeName\") throw new UnexpectedTypeError(left, \"A typescript predicate always has to have a name on the left side.\");\n            return parser.consume(\"is\"), {\n              type: \"JsdocTypePredicate\",\n              left,\n              right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n            };\n          }\n        }),\n        objectSquaredPropertyParslet = composeParslet({\n          name: \"objectSquareBracketPropertyParslet\",\n          accept: type => type === \"[\",\n          parsePrefix: parser => {\n            if (parser.baseParser === void 0) throw new Error(\"Only allowed inside object grammar\");\n            parser.consume(\"[\");\n            let key = parser.lexer.current.text;\n            parser.consume(\"Identifier\");\n            let result;\n            if (parser.consume(\":\")) {\n              let parentParser = parser.baseParser;\n              parentParser.acceptLexerState(parser), result = {\n                type: \"JsdocTypeIndexSignature\",\n                key,\n                right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n              }, parser.acceptLexerState(parentParser);\n            } else if (parser.consume(\"in\")) {\n              let parentParser = parser.baseParser;\n              parentParser.acceptLexerState(parser), result = {\n                type: \"JsdocTypeMappedType\",\n                key,\n                right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n              }, parser.acceptLexerState(parentParser);\n            } else throw new Error(\"Missing ':' or 'in' inside square bracketed property.\");\n            if (!parser.consume(\"]\")) throw new Error(\"Unterminated square brackets\");\n            return result;\n          }\n        }),\n        readonlyArrayParslet = composeParslet({\n          name: \"readonlyArrayParslet\",\n          accept: type => type === \"readonly\",\n          parsePrefix: parser => (parser.consume(\"readonly\"), {\n            type: \"JsdocTypeReadonlyArray\",\n            element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))\n          })\n        }),\n        conditionalParslet = composeParslet({\n          name: \"conditionalParslet\",\n          precedence: Precedence.INFIX,\n          accept: type => type === \"extends\",\n          parseInfix: (parser, left) => {\n            parser.consume(\"extends\");\n            let extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element,\n              trueType = parser.parseType(Precedence.INFIX);\n            return parser.consume(\":\"), {\n              type: \"JsdocTypeConditional\",\n              checksType: assertRootResult(left),\n              extendsType,\n              trueType,\n              falseType: parser.parseType(Precedence.INFIX)\n            };\n          }\n        }),\n        objectFieldGrammar = [readonlyPropertyParslet, createNameParslet({\n          allowedAdditionalTokens: [\"typeof\", \"module\", \"keyof\", \"event\", \"external\", \"in\"]\n        }), nullableParslet, optionalParslet, stringValueParslet, numberParslet, createObjectFieldParslet({\n          allowSquaredProperties: !0,\n          allowKeyTypes: !1,\n          allowOptional: !0,\n          allowReadonly: !0\n        }), objectSquaredPropertyParslet],\n        typescriptGrammar = [...baseGrammar, createObjectParslet({\n          allowKeyTypes: !1,\n          objectFieldGrammar\n        }), readonlyArrayParslet, typeOfParslet, keyOfParslet, importParslet, stringValueParslet, createFunctionParslet({\n          allowWithoutParenthesis: !0,\n          allowNoReturnType: !1,\n          allowNamedParameters: [\"this\", \"new\", \"args\"],\n          allowNewAsFunctionKeyword: !0\n        }), createTupleParslet({\n          allowQuestionMark: !1\n        }), createVariadicParslet({\n          allowEnclosingBrackets: !1,\n          allowPostfix: !1\n        }), assertsParslet, conditionalParslet, createNameParslet({\n          allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n        }), createSpecialNamePathParslet({\n          allowedTypes: [\"module\"],\n          pathGrammar\n        }), arrayBracketsParslet, arrowFunctionParslet, genericArrowFunctionParslet, createNamePathParslet({\n          allowSquareBracketsOnAnyType: !0,\n          allowJsdocNamePaths: !1,\n          pathGrammar\n        }), intersectionParslet, predicateParslet, createKeyValueParslet({\n          allowVariadic: !0,\n          allowOptional: !0\n        })];\n      function parse3(expression, mode) {\n        switch (mode) {\n          case \"closure\":\n            return new Parser(closureGrammar, expression).parse();\n          case \"jsdoc\":\n            return new Parser(jsdocGrammar, expression).parse();\n          case \"typescript\":\n            return new Parser(typescriptGrammar, expression).parse();\n        }\n      }\n      function tryParse(expression, modes = [\"typescript\", \"closure\", \"jsdoc\"]) {\n        let error;\n        for (let mode of modes) try {\n          return parse3(expression, mode);\n        } catch (e) {\n          error = e;\n        }\n        throw error;\n      }\n      function transform(rules2, parseResult) {\n        let rule = rules2[parseResult.type];\n        if (rule === void 0) throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n        return rule(parseResult, aParseResult => transform(rules2, aParseResult));\n      }\n      function notAvailableTransform(parseResult) {\n        throw new Error(\"This transform is not available. Are you trying the correct parsing mode?\");\n      }\n      function extractSpecialParams(source) {\n        let result = {\n          params: []\n        };\n        for (let param of source.parameters) param.type === \"JsdocTypeKeyValue\" ? param.key === \"this\" ? result.this = param.right : param.key === \"new\" ? result.new = param.right : result.params.push(param) : result.params.push(param);\n        return result;\n      }\n      function applyPosition(position, target, value) {\n        return position === \"prefix\" ? value + target : target + value;\n      }\n      function quote(value, quote2) {\n        switch (quote2) {\n          case \"double\":\n            return `\"${value}\"`;\n          case \"single\":\n            return `'${value}'`;\n          case void 0:\n            return value;\n        }\n      }\n      function stringifyRules2() {\n        return {\n          JsdocTypeParenthesis: (result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : \"\"})`,\n          JsdocTypeKeyof: (result, transform2) => `keyof ${transform2(result.element)}`,\n          JsdocTypeFunction: (result, transform2) => {\n            var _a;\n            if (result.arrow) {\n              if (result.returnType === void 0) throw new Error(\"Arrow function needs a return type.\");\n              let stringified = `${result.typeParameters !== void 0 ? `<${(_a = result.typeParameters.map(transform2).join(\", \")) !== null && _a !== void 0 ? _a : \"\"}>` : \"\"}(${result.parameters.map(transform2).join(\", \")}) => ${transform2(result.returnType)}`;\n              return result.constructor && (stringified = \"new \" + stringified), stringified;\n            } else {\n              let stringified = result.constructor ? \"new\" : \"function\";\n              return result.parenthesis && (stringified += `(${result.parameters.map(transform2).join(\", \")})`, result.returnType !== void 0 && (stringified += `: ${transform2(result.returnType)}`)), stringified;\n            }\n          },\n          JsdocTypeName: result => result.value,\n          JsdocTypeTuple: (result, transform2) => `[${result.elements.map(transform2).join(\", \")}]`,\n          JsdocTypeVariadic: (result, transform2) => result.meta.position === void 0 ? \"...\" : applyPosition(result.meta.position, transform2(result.element), \"...\"),\n          JsdocTypeNamePath: (result, transform2) => {\n            let left = transform2(result.left),\n              right = transform2(result.right);\n            switch (result.pathType) {\n              case \"inner\":\n                return `${left}~${right}`;\n              case \"instance\":\n                return `${left}#${right}`;\n              case \"property\":\n                return `${left}.${right}`;\n              case \"property-brackets\":\n                return `${left}[${right}]`;\n            }\n          },\n          JsdocTypeStringValue: result => quote(result.value, result.meta.quote),\n          JsdocTypeAny: () => \"*\",\n          JsdocTypeGeneric: (result, transform2) => {\n            if (result.meta.brackets === \"square\") {\n              let element = result.elements[0],\n                transformed = transform2(element);\n              return element.type === \"JsdocTypeUnion\" || element.type === \"JsdocTypeIntersection\" ? `(${transformed})[]` : `${transformed}[]`;\n            } else return `${transform2(result.left)}${result.meta.dot ? \".\" : \"\"}<${result.infer === !0 ? \"infer \" : \"\"}${result.elements.map(transform2).join(\", \")}>`;\n          },\n          JsdocTypeImport: (result, transform2) => `import(${transform2(result.element)})`,\n          JsdocTypeObjectField: (result, transform2) => {\n            let text = \"\";\n            return result.readonly && (text += \"readonly \"), typeof result.key == \"string\" ? text += quote(result.key, result.meta.quote) : text += transform2(result.key), result.optional && (text += \"?\"), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;\n          },\n          JsdocTypeJsdocObjectField: (result, transform2) => `${transform2(result.left)}: ${transform2(result.right)}`,\n          JsdocTypeKeyValue: (result, transform2) => {\n            let text = result.key;\n            return result.optional && (text += \"?\"), result.variadic && (text = \"...\" + text), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;\n          },\n          JsdocTypeSpecialNamePath: result => `${result.specialType}:${quote(result.value, result.meta.quote)}`,\n          JsdocTypeNotNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"!\"),\n          JsdocTypeNull: () => \"null\",\n          JsdocTypeNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"?\"),\n          JsdocTypeNumber: result => result.value.toString(),\n          JsdocTypeObject: (result, transform2) => {\n            var _a, _b;\n            return `{${(result.meta.separator === \"linebreak\" && result.elements.length > 1 ? `\n` + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : \"\") : \"\") + result.elements.map(transform2).join(result.meta.separator === \"comma\" ? \", \" : result.meta.separator === \"linebreak\" ? `\n` + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : \"\") : \"; \") + (result.meta.separator === \"linebreak\" && result.elements.length > 1 ? `\n` : \"\")}}`;\n          },\n          JsdocTypeOptional: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"=\"),\n          JsdocTypeSymbol: (result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : \"\"})`,\n          JsdocTypeTypeof: (result, transform2) => `typeof ${transform2(result.element)}`,\n          JsdocTypeUndefined: () => \"undefined\",\n          JsdocTypeUnion: (result, transform2) => result.elements.map(transform2).join(\" | \"),\n          JsdocTypeUnknown: () => \"?\",\n          JsdocTypeIntersection: (result, transform2) => result.elements.map(transform2).join(\" & \"),\n          JsdocTypeProperty: result => quote(result.value, result.meta.quote),\n          JsdocTypePredicate: (result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`,\n          JsdocTypeIndexSignature: (result, transform2) => `[${result.key}: ${transform2(result.right)}]`,\n          JsdocTypeMappedType: (result, transform2) => `[${result.key} in ${transform2(result.right)}]`,\n          JsdocTypeAsserts: (result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`,\n          JsdocTypeReadonlyArray: (result, transform2) => `readonly ${transform2(result.element)}`,\n          JsdocTypeAssertsPlain: (result, transform2) => `asserts ${transform2(result.element)}`,\n          JsdocTypeConditional: (result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`,\n          JsdocTypeTypeParameter: (result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : \"\"}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : \"\"}`\n        };\n      }\n      let storedStringifyRules = stringifyRules2();\n      function stringify2(result) {\n        return transform(storedStringifyRules, result);\n      }\n      let reservedWords = [\"null\", \"true\", \"false\", \"break\", \"case\", \"catch\", \"class\", \"const\", \"continue\", \"debugger\", \"default\", \"delete\", \"do\", \"else\", \"export\", \"extends\", \"finally\", \"for\", \"function\", \"if\", \"import\", \"in\", \"instanceof\", \"new\", \"return\", \"super\", \"switch\", \"this\", \"throw\", \"try\", \"typeof\", \"var\", \"void\", \"while\", \"with\", \"yield\"];\n      function makeName(value) {\n        let result = {\n          type: \"NameExpression\",\n          name: value\n        };\n        return reservedWords.includes(value) && (result.reservedWord = !0), result;\n      }\n      let catharsisTransformRules = {\n        JsdocTypeOptional: (result, transform2) => {\n          let transformed = transform2(result.element);\n          return transformed.optional = !0, transformed;\n        },\n        JsdocTypeNullable: (result, transform2) => {\n          let transformed = transform2(result.element);\n          return transformed.nullable = !0, transformed;\n        },\n        JsdocTypeNotNullable: (result, transform2) => {\n          let transformed = transform2(result.element);\n          return transformed.nullable = !1, transformed;\n        },\n        JsdocTypeVariadic: (result, transform2) => {\n          if (result.element === void 0) throw new Error(\"dots without value are not allowed in catharsis mode\");\n          let transformed = transform2(result.element);\n          return transformed.repeatable = !0, transformed;\n        },\n        JsdocTypeAny: () => ({\n          type: \"AllLiteral\"\n        }),\n        JsdocTypeNull: () => ({\n          type: \"NullLiteral\"\n        }),\n        JsdocTypeStringValue: result => makeName(quote(result.value, result.meta.quote)),\n        JsdocTypeUndefined: () => ({\n          type: \"UndefinedLiteral\"\n        }),\n        JsdocTypeUnknown: () => ({\n          type: \"UnknownLiteral\"\n        }),\n        JsdocTypeFunction: (result, transform2) => {\n          let params = extractSpecialParams(result),\n            transformed = {\n              type: \"FunctionType\",\n              params: params.params.map(transform2)\n            };\n          return params.this !== void 0 && (transformed.this = transform2(params.this)), params.new !== void 0 && (transformed.new = transform2(params.new)), result.returnType !== void 0 && (transformed.result = transform2(result.returnType)), transformed;\n        },\n        JsdocTypeGeneric: (result, transform2) => ({\n          type: \"TypeApplication\",\n          applications: result.elements.map(o => transform2(o)),\n          expression: transform2(result.left)\n        }),\n        JsdocTypeSpecialNamePath: result => makeName(result.specialType + \":\" + quote(result.value, result.meta.quote)),\n        JsdocTypeName: result => result.value !== \"function\" ? makeName(result.value) : {\n          type: \"FunctionType\",\n          params: []\n        },\n        JsdocTypeNumber: result => makeName(result.value.toString()),\n        JsdocTypeObject: (result, transform2) => {\n          let transformed = {\n            type: \"RecordType\",\n            fields: []\n          };\n          for (let field of result.elements) field.type !== \"JsdocTypeObjectField\" && field.type !== \"JsdocTypeJsdocObjectField\" ? transformed.fields.push({\n            type: \"FieldType\",\n            key: transform2(field),\n            value: void 0\n          }) : transformed.fields.push(transform2(field));\n          return transformed;\n        },\n        JsdocTypeObjectField: (result, transform2) => {\n          if (typeof result.key != \"string\") throw new Error(\"Index signatures and mapped types are not supported\");\n          return {\n            type: \"FieldType\",\n            key: makeName(quote(result.key, result.meta.quote)),\n            value: result.right === void 0 ? void 0 : transform2(result.right)\n          };\n        },\n        JsdocTypeJsdocObjectField: (result, transform2) => ({\n          type: \"FieldType\",\n          key: transform2(result.left),\n          value: transform2(result.right)\n        }),\n        JsdocTypeUnion: (result, transform2) => ({\n          type: \"TypeUnion\",\n          elements: result.elements.map(e => transform2(e))\n        }),\n        JsdocTypeKeyValue: (result, transform2) => ({\n          type: \"FieldType\",\n          key: makeName(result.key),\n          value: result.right === void 0 ? void 0 : transform2(result.right)\n        }),\n        JsdocTypeNamePath: (result, transform2) => {\n          let leftResult = transform2(result.left),\n            rightValue;\n          result.right.type === \"JsdocTypeSpecialNamePath\" ? rightValue = transform2(result.right).name : rightValue = quote(result.right.value, result.right.meta.quote);\n          let joiner = result.pathType === \"inner\" ? \"~\" : result.pathType === \"instance\" ? \"#\" : \".\";\n          return makeName(`${leftResult.name}${joiner}${rightValue}`);\n        },\n        JsdocTypeSymbol: result => {\n          let value = \"\",\n            element = result.element,\n            trailingDots = !1;\n          return element?.type === \"JsdocTypeVariadic\" && (element.meta.position === \"prefix\" ? value = \"...\" : trailingDots = !0, element = element.element), element?.type === \"JsdocTypeName\" ? value += element.value : element?.type === \"JsdocTypeNumber\" && (value += element.value.toString()), trailingDots && (value += \"...\"), makeName(`${result.value}(${value})`);\n        },\n        JsdocTypeParenthesis: (result, transform2) => transform2(assertRootResult(result.element)),\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeImport: notAvailableTransform,\n        JsdocTypeKeyof: notAvailableTransform,\n        JsdocTypeTuple: notAvailableTransform,\n        JsdocTypeTypeof: notAvailableTransform,\n        JsdocTypeIntersection: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n      };\n      function catharsisTransform(result) {\n        return transform(catharsisTransformRules, result);\n      }\n      function getQuoteStyle(quote2) {\n        switch (quote2) {\n          case void 0:\n            return \"none\";\n          case \"single\":\n            return \"single\";\n          case \"double\":\n            return \"double\";\n        }\n      }\n      function getMemberType(type) {\n        switch (type) {\n          case \"inner\":\n            return \"INNER_MEMBER\";\n          case \"instance\":\n            return \"INSTANCE_MEMBER\";\n          case \"property\":\n            return \"MEMBER\";\n          case \"property-brackets\":\n            return \"MEMBER\";\n        }\n      }\n      function nestResults(type, results) {\n        return results.length === 2 ? {\n          type,\n          left: results[0],\n          right: results[1]\n        } : {\n          type,\n          left: results[0],\n          right: nestResults(type, results.slice(1))\n        };\n      }\n      let jtpRules = {\n        JsdocTypeOptional: (result, transform2) => ({\n          type: \"OPTIONAL\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_EQUAL_SIGN\" : \"SUFFIX_EQUALS_SIGN\"\n          }\n        }),\n        JsdocTypeNullable: (result, transform2) => ({\n          type: \"NULLABLE\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_QUESTION_MARK\" : \"SUFFIX_QUESTION_MARK\"\n          }\n        }),\n        JsdocTypeNotNullable: (result, transform2) => ({\n          type: \"NOT_NULLABLE\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_BANG\" : \"SUFFIX_BANG\"\n          }\n        }),\n        JsdocTypeVariadic: (result, transform2) => {\n          let transformed = {\n            type: \"VARIADIC\",\n            meta: {\n              syntax: result.meta.position === \"prefix\" ? \"PREFIX_DOTS\" : result.meta.position === \"suffix\" ? \"SUFFIX_DOTS\" : \"ONLY_DOTS\"\n            }\n          };\n          return result.element !== void 0 && (transformed.value = transform2(result.element)), transformed;\n        },\n        JsdocTypeName: result => ({\n          type: \"NAME\",\n          name: result.value\n        }),\n        JsdocTypeTypeof: (result, transform2) => ({\n          type: \"TYPE_QUERY\",\n          name: transform2(result.element)\n        }),\n        JsdocTypeTuple: (result, transform2) => ({\n          type: \"TUPLE\",\n          entries: result.elements.map(transform2)\n        }),\n        JsdocTypeKeyof: (result, transform2) => ({\n          type: \"KEY_QUERY\",\n          value: transform2(result.element)\n        }),\n        JsdocTypeImport: result => ({\n          type: \"IMPORT\",\n          path: {\n            type: \"STRING_VALUE\",\n            quoteStyle: getQuoteStyle(result.element.meta.quote),\n            string: result.element.value\n          }\n        }),\n        JsdocTypeUndefined: () => ({\n          type: \"NAME\",\n          name: \"undefined\"\n        }),\n        JsdocTypeAny: () => ({\n          type: \"ANY\"\n        }),\n        JsdocTypeFunction: (result, transform2) => {\n          let specialParams = extractSpecialParams(result),\n            transformed = {\n              type: result.arrow ? \"ARROW\" : \"FUNCTION\",\n              params: specialParams.params.map(param => {\n                if (param.type === \"JsdocTypeKeyValue\") {\n                  if (param.right === void 0) throw new Error(\"Function parameter without ':' is not expected to be 'KEY_VALUE'\");\n                  return {\n                    type: \"NAMED_PARAMETER\",\n                    name: param.key,\n                    typeName: transform2(param.right)\n                  };\n                } else return transform2(param);\n              }),\n              new: null,\n              returns: null\n            };\n          return specialParams.this !== void 0 ? transformed.this = transform2(specialParams.this) : result.arrow || (transformed.this = null), specialParams.new !== void 0 && (transformed.new = transform2(specialParams.new)), result.returnType !== void 0 && (transformed.returns = transform2(result.returnType)), transformed;\n        },\n        JsdocTypeGeneric: (result, transform2) => {\n          let transformed = {\n            type: \"GENERIC\",\n            subject: transform2(result.left),\n            objects: result.elements.map(transform2),\n            meta: {\n              syntax: result.meta.brackets === \"square\" ? \"SQUARE_BRACKET\" : result.meta.dot ? \"ANGLE_BRACKET_WITH_DOT\" : \"ANGLE_BRACKET\"\n            }\n          };\n          return result.meta.brackets === \"square\" && result.elements[0].type === \"JsdocTypeFunction\" && !result.elements[0].parenthesis && (transformed.objects[0] = {\n            type: \"NAME\",\n            name: \"function\"\n          }), transformed;\n        },\n        JsdocTypeObjectField: (result, transform2) => {\n          if (typeof result.key != \"string\") throw new Error(\"Index signatures and mapped types are not supported\");\n          if (result.right === void 0) return {\n            type: \"RECORD_ENTRY\",\n            key: result.key,\n            quoteStyle: getQuoteStyle(result.meta.quote),\n            value: null,\n            readonly: !1\n          };\n          let right = transform2(result.right);\n          return result.optional && (right = {\n            type: \"OPTIONAL\",\n            value: right,\n            meta: {\n              syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n            }\n          }), {\n            type: \"RECORD_ENTRY\",\n            key: result.key.toString(),\n            quoteStyle: getQuoteStyle(result.meta.quote),\n            value: right,\n            readonly: !1\n          };\n        },\n        JsdocTypeJsdocObjectField: () => {\n          throw new Error(\"Keys may not be typed in jsdoctypeparser.\");\n        },\n        JsdocTypeKeyValue: (result, transform2) => {\n          if (result.right === void 0) return {\n            type: \"RECORD_ENTRY\",\n            key: result.key,\n            quoteStyle: \"none\",\n            value: null,\n            readonly: !1\n          };\n          let right = transform2(result.right);\n          return result.optional && (right = {\n            type: \"OPTIONAL\",\n            value: right,\n            meta: {\n              syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n            }\n          }), {\n            type: \"RECORD_ENTRY\",\n            key: result.key,\n            quoteStyle: \"none\",\n            value: right,\n            readonly: !1\n          };\n        },\n        JsdocTypeObject: (result, transform2) => {\n          let entries = [];\n          for (let field of result.elements) (field.type === \"JsdocTypeObjectField\" || field.type === \"JsdocTypeJsdocObjectField\") && entries.push(transform2(field));\n          return {\n            type: \"RECORD\",\n            entries\n          };\n        },\n        JsdocTypeSpecialNamePath: result => {\n          if (result.specialType !== \"module\") throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n          return {\n            type: \"MODULE\",\n            value: {\n              type: \"FILE_PATH\",\n              quoteStyle: getQuoteStyle(result.meta.quote),\n              path: result.value\n            }\n          };\n        },\n        JsdocTypeNamePath: (result, transform2) => {\n          let hasEventPrefix = !1,\n            name,\n            quoteStyle;\n          result.right.type === \"JsdocTypeSpecialNamePath\" && result.right.specialType === \"event\" ? (hasEventPrefix = !0, name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote)) : (name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote));\n          let transformed = {\n            type: getMemberType(result.pathType),\n            owner: transform2(result.left),\n            name,\n            quoteStyle,\n            hasEventPrefix\n          };\n          if (transformed.owner.type === \"MODULE\") {\n            let tModule = transformed.owner;\n            return transformed.owner = transformed.owner.value, tModule.value = transformed, tModule;\n          } else return transformed;\n        },\n        JsdocTypeUnion: (result, transform2) => nestResults(\"UNION\", result.elements.map(transform2)),\n        JsdocTypeParenthesis: (result, transform2) => ({\n          type: \"PARENTHESIS\",\n          value: transform2(assertRootResult(result.element))\n        }),\n        JsdocTypeNull: () => ({\n          type: \"NAME\",\n          name: \"null\"\n        }),\n        JsdocTypeUnknown: () => ({\n          type: \"UNKNOWN\"\n        }),\n        JsdocTypeStringValue: result => ({\n          type: \"STRING_VALUE\",\n          quoteStyle: getQuoteStyle(result.meta.quote),\n          string: result.value\n        }),\n        JsdocTypeIntersection: (result, transform2) => nestResults(\"INTERSECTION\", result.elements.map(transform2)),\n        JsdocTypeNumber: result => ({\n          type: \"NUMBER_VALUE\",\n          number: result.value.toString()\n        }),\n        JsdocTypeSymbol: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n      };\n      function jtpTransform(result) {\n        return transform(jtpRules, result);\n      }\n      function identityTransformRules() {\n        return {\n          JsdocTypeIntersection: (result, transform2) => ({\n            type: \"JsdocTypeIntersection\",\n            elements: result.elements.map(transform2)\n          }),\n          JsdocTypeGeneric: (result, transform2) => ({\n            type: \"JsdocTypeGeneric\",\n            left: transform2(result.left),\n            elements: result.elements.map(transform2),\n            meta: {\n              dot: result.meta.dot,\n              brackets: result.meta.brackets\n            }\n          }),\n          JsdocTypeNullable: result => result,\n          JsdocTypeUnion: (result, transform2) => ({\n            type: \"JsdocTypeUnion\",\n            elements: result.elements.map(transform2)\n          }),\n          JsdocTypeUnknown: result => result,\n          JsdocTypeUndefined: result => result,\n          JsdocTypeTypeof: (result, transform2) => ({\n            type: \"JsdocTypeTypeof\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeSymbol: (result, transform2) => {\n            let transformed = {\n              type: \"JsdocTypeSymbol\",\n              value: result.value\n            };\n            return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;\n          },\n          JsdocTypeOptional: (result, transform2) => ({\n            type: \"JsdocTypeOptional\",\n            element: transform2(result.element),\n            meta: {\n              position: result.meta.position\n            }\n          }),\n          JsdocTypeObject: (result, transform2) => ({\n            type: \"JsdocTypeObject\",\n            meta: {\n              separator: \"comma\"\n            },\n            elements: result.elements.map(transform2)\n          }),\n          JsdocTypeNumber: result => result,\n          JsdocTypeNull: result => result,\n          JsdocTypeNotNullable: (result, transform2) => ({\n            type: \"JsdocTypeNotNullable\",\n            element: transform2(result.element),\n            meta: {\n              position: result.meta.position\n            }\n          }),\n          JsdocTypeSpecialNamePath: result => result,\n          JsdocTypeObjectField: (result, transform2) => ({\n            type: \"JsdocTypeObjectField\",\n            key: result.key,\n            right: result.right === void 0 ? void 0 : transform2(result.right),\n            optional: result.optional,\n            readonly: result.readonly,\n            meta: result.meta\n          }),\n          JsdocTypeJsdocObjectField: (result, transform2) => ({\n            type: \"JsdocTypeJsdocObjectField\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }),\n          JsdocTypeKeyValue: (result, transform2) => ({\n            type: \"JsdocTypeKeyValue\",\n            key: result.key,\n            right: result.right === void 0 ? void 0 : transform2(result.right),\n            optional: result.optional,\n            variadic: result.variadic\n          }),\n          JsdocTypeImport: (result, transform2) => ({\n            type: \"JsdocTypeImport\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeAny: result => result,\n          JsdocTypeStringValue: result => result,\n          JsdocTypeNamePath: result => result,\n          JsdocTypeVariadic: (result, transform2) => {\n            let transformed = {\n              type: \"JsdocTypeVariadic\",\n              meta: {\n                position: result.meta.position,\n                squareBrackets: result.meta.squareBrackets\n              }\n            };\n            return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;\n          },\n          JsdocTypeTuple: (result, transform2) => ({\n            type: \"JsdocTypeTuple\",\n            elements: result.elements.map(transform2)\n          }),\n          JsdocTypeName: result => result,\n          JsdocTypeFunction: (result, transform2) => {\n            let transformed = {\n              type: \"JsdocTypeFunction\",\n              arrow: result.arrow,\n              parameters: result.parameters.map(transform2),\n              constructor: result.constructor,\n              parenthesis: result.parenthesis\n            };\n            return result.returnType !== void 0 && (transformed.returnType = transform2(result.returnType)), transformed;\n          },\n          JsdocTypeKeyof: (result, transform2) => ({\n            type: \"JsdocTypeKeyof\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeParenthesis: (result, transform2) => ({\n            type: \"JsdocTypeParenthesis\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeProperty: result => result,\n          JsdocTypePredicate: (result, transform2) => ({\n            type: \"JsdocTypePredicate\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }),\n          JsdocTypeIndexSignature: (result, transform2) => ({\n            type: \"JsdocTypeIndexSignature\",\n            key: result.key,\n            right: transform2(result.right)\n          }),\n          JsdocTypeMappedType: (result, transform2) => ({\n            type: \"JsdocTypeMappedType\",\n            key: result.key,\n            right: transform2(result.right)\n          }),\n          JsdocTypeAsserts: (result, transform2) => ({\n            type: \"JsdocTypeAsserts\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }),\n          JsdocTypeReadonlyArray: (result, transform2) => ({\n            type: \"JsdocTypeReadonlyArray\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeAssertsPlain: (result, transform2) => ({\n            type: \"JsdocTypeAssertsPlain\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeConditional: (result, transform2) => ({\n            type: \"JsdocTypeConditional\",\n            checksType: transform2(result.checksType),\n            extendsType: transform2(result.extendsType),\n            trueType: transform2(result.trueType),\n            falseType: transform2(result.falseType)\n          }),\n          JsdocTypeTypeParameter: (result, transform2) => ({\n            type: \"JsdocTypeTypeParameter\",\n            name: transform2(result.name),\n            constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,\n            defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0\n          })\n        };\n      }\n      let visitorKeys = {\n        JsdocTypeAny: [],\n        JsdocTypeFunction: [\"parameters\", \"returnType\"],\n        JsdocTypeGeneric: [\"left\", \"elements\"],\n        JsdocTypeImport: [],\n        JsdocTypeIndexSignature: [\"right\"],\n        JsdocTypeIntersection: [\"elements\"],\n        JsdocTypeKeyof: [\"element\"],\n        JsdocTypeKeyValue: [\"right\"],\n        JsdocTypeMappedType: [\"right\"],\n        JsdocTypeName: [],\n        JsdocTypeNamePath: [\"left\", \"right\"],\n        JsdocTypeNotNullable: [\"element\"],\n        JsdocTypeNull: [],\n        JsdocTypeNullable: [\"element\"],\n        JsdocTypeNumber: [],\n        JsdocTypeObject: [\"elements\"],\n        JsdocTypeObjectField: [\"right\"],\n        JsdocTypeJsdocObjectField: [\"left\", \"right\"],\n        JsdocTypeOptional: [\"element\"],\n        JsdocTypeParenthesis: [\"element\"],\n        JsdocTypeSpecialNamePath: [],\n        JsdocTypeStringValue: [],\n        JsdocTypeSymbol: [\"element\"],\n        JsdocTypeTuple: [\"elements\"],\n        JsdocTypeTypeof: [\"element\"],\n        JsdocTypeUndefined: [],\n        JsdocTypeUnion: [\"elements\"],\n        JsdocTypeUnknown: [],\n        JsdocTypeVariadic: [\"element\"],\n        JsdocTypeProperty: [],\n        JsdocTypePredicate: [\"left\", \"right\"],\n        JsdocTypeAsserts: [\"left\", \"right\"],\n        JsdocTypeReadonlyArray: [\"element\"],\n        JsdocTypeAssertsPlain: [\"element\"],\n        JsdocTypeConditional: [\"checksType\", \"extendsType\", \"trueType\", \"falseType\"],\n        JsdocTypeTypeParameter: [\"name\", \"constraint\", \"defaultValue\"]\n      };\n      function _traverse(node, parentNode, property, onEnter, onLeave) {\n        onEnter?.(node, parentNode, property);\n        let keysToVisit = visitorKeys[node.type];\n        for (let key of keysToVisit) {\n          let value = node[key];\n          if (value !== void 0) if (Array.isArray(value)) for (let element of value) _traverse(element, node, key, onEnter, onLeave);else _traverse(value, node, key, onEnter, onLeave);\n        }\n        onLeave?.(node, parentNode, property);\n      }\n      function traverse(node, onEnter, onLeave) {\n        _traverse(node, void 0, void 0, onEnter, onLeave);\n      }\n      exports2.catharsisTransform = catharsisTransform, exports2.identityTransformRules = identityTransformRules, exports2.jtpTransform = jtpTransform, exports2.parse = parse3, exports2.stringify = stringify2, exports2.stringifyRules = stringifyRules2, exports2.transform = transform, exports2.traverse = traverse, exports2.tryParse = tryParse, exports2.visitorKeys = visitorKeys;\n    });\n  }\n});\n\n// src/docs-tools/argTypes/convert/flow/convert.ts\nimport { UnknownArgTypesError } from \"storybook/internal/preview-errors\";\nvar isLiteral = type => type.name === \"literal\",\n  toEnumOption = element => element.value.replace(/['|\"]/g, \"\"),\n  convertSig = type => {\n    switch (type.type) {\n      case \"function\":\n        return {\n          name: \"function\"\n        };\n      case \"object\":\n        let values = {};\n        return type.signature.properties.forEach(prop => {\n          values[prop.key] = convert(prop.value);\n        }), {\n          name: \"object\",\n          value: values\n        };\n      default:\n        throw new UnknownArgTypesError({\n          type,\n          language: \"Flow\"\n        });\n    }\n  },\n  convert = type => {\n    let {\n        name,\n        raw\n      } = type,\n      base = {};\n    switch (typeof raw < \"u\" && (base.raw = raw), type.name) {\n      case \"literal\":\n        return {\n          ...base,\n          name: \"other\",\n          value: type.value\n        };\n      case \"string\":\n      case \"number\":\n      case \"symbol\":\n      case \"boolean\":\n        return {\n          ...base,\n          name\n        };\n      case \"Array\":\n        return {\n          ...base,\n          name: \"array\",\n          value: type.elements.map(convert)\n        };\n      case \"signature\":\n        return {\n          ...base,\n          ...convertSig(type)\n        };\n      case \"union\":\n        return type.elements?.every(isLiteral) ? {\n          ...base,\n          name: \"enum\",\n          value: type.elements?.map(toEnumOption)\n        } : {\n          ...base,\n          name,\n          value: type.elements?.map(convert)\n        };\n      case \"intersection\":\n        return {\n          ...base,\n          name,\n          value: type.elements?.map(convert)\n        };\n      default:\n        return {\n          ...base,\n          name: \"other\",\n          value: name\n        };\n    }\n  };\n\n// src/docs-tools/argTypes/convert/utils.ts\nvar QUOTE_REGEX = /^['\"]|['\"]$/g,\n  trimQuotes = str2 => str2.replace(QUOTE_REGEX, \"\"),\n  includesQuotes = str2 => QUOTE_REGEX.test(str2),\n  parseLiteral = str2 => {\n    let trimmedValue = trimQuotes(str2);\n    return includesQuotes(str2) || Number.isNaN(Number(trimmedValue)) ? trimmedValue : Number(trimmedValue);\n  };\n\n// src/docs-tools/argTypes/convert/proptypes/convert.ts\nvar SIGNATURE_REGEXP = /^\\(.*\\) => /,\n  convert2 = type => {\n    let {\n        name,\n        raw,\n        computed,\n        value\n      } = type,\n      base = {};\n    switch (typeof raw < \"u\" && (base.raw = raw), name) {\n      case \"enum\":\n        {\n          let values2 = computed ? value : value.map(v => parseLiteral(v.value));\n          return {\n            ...base,\n            name,\n            value: values2\n          };\n        }\n      case \"string\":\n      case \"number\":\n      case \"symbol\":\n        return {\n          ...base,\n          name\n        };\n      case \"func\":\n        return {\n          ...base,\n          name: \"function\"\n        };\n      case \"bool\":\n      case \"boolean\":\n        return {\n          ...base,\n          name: \"boolean\"\n        };\n      case \"arrayOf\":\n      case \"array\":\n        return {\n          ...base,\n          name: \"array\",\n          value: value && convert2(value)\n        };\n      case \"object\":\n        return {\n          ...base,\n          name\n        };\n      case \"objectOf\":\n        return {\n          ...base,\n          name,\n          value: convert2(value)\n        };\n      case \"shape\":\n      case \"exact\":\n        let values = mapValues(value, field => convert2(field));\n        return {\n          ...base,\n          name: \"object\",\n          value: values\n        };\n      case \"union\":\n        return {\n          ...base,\n          name: \"union\",\n          value: value.map(v => convert2(v))\n        };\n      case \"instanceOf\":\n      case \"element\":\n      case \"elementType\":\n      default:\n        {\n          if (name?.indexOf(\"|\") > 0) try {\n            let literalValues = name.split(\"|\").map(v => JSON.parse(v));\n            return {\n              ...base,\n              name: \"enum\",\n              value: literalValues\n            };\n          } catch {}\n          let otherVal = value ? `${name}(${value})` : name,\n            otherName = SIGNATURE_REGEXP.test(name) ? \"function\" : \"other\";\n          return {\n            ...base,\n            name: otherName,\n            value: otherVal\n          };\n        }\n    }\n  };\n\n// src/docs-tools/argTypes/convert/typescript/convert.ts\nimport { UnknownArgTypesError as UnknownArgTypesError2 } from \"storybook/internal/preview-errors\";\nvar convertSig2 = type => {\n    switch (type.type) {\n      case \"function\":\n        return {\n          name: \"function\"\n        };\n      case \"object\":\n        let values = {};\n        return type.signature.properties.forEach(prop => {\n          values[prop.key] = convert3(prop.value);\n        }), {\n          name: \"object\",\n          value: values\n        };\n      default:\n        throw new UnknownArgTypesError2({\n          type,\n          language: \"Typescript\"\n        });\n    }\n  },\n  convert3 = type => {\n    let {\n        name,\n        raw\n      } = type,\n      base = {};\n    switch (typeof raw < \"u\" && (base.raw = raw), type.name) {\n      case \"string\":\n      case \"number\":\n      case \"symbol\":\n      case \"boolean\":\n        return {\n          ...base,\n          name\n        };\n      case \"Array\":\n        return {\n          ...base,\n          name: \"array\",\n          value: type.elements.map(convert3)\n        };\n      case \"signature\":\n        return {\n          ...base,\n          ...convertSig2(type)\n        };\n      case \"union\":\n        let result;\n        return type.elements?.every(element => element.name === \"literal\") ? result = {\n          ...base,\n          name: \"enum\",\n          // @ts-expect-error fix types\n          value: type.elements?.map(v => parseLiteral(v.value))\n        } : result = {\n          ...base,\n          name,\n          value: type.elements?.map(convert3)\n        }, result;\n      case \"intersection\":\n        return {\n          ...base,\n          name,\n          value: type.elements?.map(convert3)\n        };\n      default:\n        return {\n          ...base,\n          name: \"other\",\n          value: name\n        };\n    }\n  };\n\n// src/docs-tools/argTypes/convert/index.ts\nvar convert4 = docgenInfo => {\n  let {\n    type,\n    tsType,\n    flowType\n  } = docgenInfo;\n  try {\n    if (type != null) return convert2(type);\n    if (tsType != null) return convert3(tsType);\n    if (flowType != null) return convert(flowType);\n  } catch (err) {\n    console.error(err);\n  }\n  return null;\n};\n\n// src/docs-tools/argTypes/docgen/types.ts\nvar TypeSystem = /* @__PURE__ */(TypeSystem2 => (TypeSystem2.JAVASCRIPT = \"JavaScript\", TypeSystem2.FLOW = \"Flow\", TypeSystem2.TYPESCRIPT = \"TypeScript\", TypeSystem2.UNKNOWN = \"Unknown\", TypeSystem2))(TypeSystem || {});\n\n// src/docs-tools/argTypes/docgen/utils/defaultValue.ts\nvar BLACKLIST = [\"null\", \"undefined\"];\nfunction isDefaultValueBlacklisted(value) {\n  return BLACKLIST.some(x => x === value);\n}\n\n// src/docs-tools/argTypes/docgen/utils/string.ts\nvar str = obj => {\n  if (!obj) return \"\";\n  if (typeof obj == \"string\") return obj;\n  throw new Error(`Description: expected string, got: ${JSON.stringify(obj)}`);\n};\n\n// src/docs-tools/argTypes/docgen/utils/docgenInfo.ts\nfunction hasDocgen(component) {\n  return !!component.__docgenInfo;\n}\nfunction isValidDocgenSection(docgenSection) {\n  return docgenSection != null && Object.keys(docgenSection).length > 0;\n}\nfunction getDocgenSection(component, section) {\n  return hasDocgen(component) ? component.__docgenInfo[section] : null;\n}\nfunction getDocgenDescription(component) {\n  return hasDocgen(component) ? str(component.__docgenInfo.description) : \"\";\n}\n\n// ../node_modules/comment-parser/es6/primitives.js\nvar Markers;\n(function (Markers2) {\n  Markers2.start = \"/**\", Markers2.nostart = \"/***\", Markers2.delim = \"*\", Markers2.end = \"*/\";\n})(Markers = Markers || (Markers = {}));\n\n// ../node_modules/comment-parser/es6/util.js\nfunction isSpace(source) {\n  return /^\\s+$/.test(source);\n}\nfunction splitCR(source) {\n  let matches = source.match(/\\r+$/);\n  return matches == null ? [\"\", source] : [source.slice(-matches[0].length), source.slice(0, -matches[0].length)];\n}\nfunction splitSpace(source) {\n  let matches = source.match(/^\\s+/);\n  return matches == null ? [\"\", source] : [source.slice(0, matches[0].length), source.slice(matches[0].length)];\n}\nfunction splitLines(source) {\n  return source.split(/\\n/);\n}\nfunction seedSpec(spec = {}) {\n  return Object.assign({\n    tag: \"\",\n    name: \"\",\n    type: \"\",\n    optional: !1,\n    description: \"\",\n    problems: [],\n    source: []\n  }, spec);\n}\nfunction seedTokens(tokens = {}) {\n  return Object.assign({\n    start: \"\",\n    delimiter: \"\",\n    postDelimiter: \"\",\n    tag: \"\",\n    postTag: \"\",\n    name: \"\",\n    postName: \"\",\n    type: \"\",\n    postType: \"\",\n    description: \"\",\n    end: \"\",\n    lineEnd: \"\"\n  }, tokens);\n}\n\n// ../node_modules/comment-parser/es6/parser/block-parser.js\nvar reTag = /^@\\S+/;\nfunction getParser({\n  fence = \"```\"\n} = {}) {\n  let fencer = getFencer(fence),\n    toggleFence = (source, isFenced) => fencer(source) ? !isFenced : isFenced;\n  return function (source) {\n    let sections = [[]],\n      isFenced = !1;\n    for (let line of source) reTag.test(line.tokens.description) && !isFenced ? sections.push([line]) : sections[sections.length - 1].push(line), isFenced = toggleFence(line.tokens.description, isFenced);\n    return sections;\n  };\n}\nfunction getFencer(fence) {\n  return typeof fence == \"string\" ? source => source.split(fence).length % 2 === 0 : fence;\n}\n\n// ../node_modules/comment-parser/es6/parser/source-parser.js\nfunction getParser2({\n  startLine = 0,\n  markers = Markers\n} = {}) {\n  let block = null,\n    num = startLine;\n  return function (source) {\n    let rest = source,\n      tokens = seedTokens();\n    if ([tokens.lineEnd, rest] = splitCR(rest), [tokens.start, rest] = splitSpace(rest), block === null && rest.startsWith(markers.start) && !rest.startsWith(markers.nostart) && (block = [], tokens.delimiter = rest.slice(0, markers.start.length), rest = rest.slice(markers.start.length), [tokens.postDelimiter, rest] = splitSpace(rest)), block === null) return num++, null;\n    let isClosed = rest.trimRight().endsWith(markers.end);\n    if (tokens.delimiter === \"\" && rest.startsWith(markers.delim) && !rest.startsWith(markers.end) && (tokens.delimiter = markers.delim, rest = rest.slice(markers.delim.length), [tokens.postDelimiter, rest] = splitSpace(rest)), isClosed) {\n      let trimmed = rest.trimRight();\n      tokens.end = rest.slice(trimmed.length - markers.end.length), rest = trimmed.slice(0, -markers.end.length);\n    }\n    if (tokens.description = rest, block.push({\n      number: num,\n      source,\n      tokens\n    }), num++, isClosed) {\n      let result = block.slice();\n      return block = null, result;\n    }\n    return null;\n  };\n}\n\n// ../node_modules/comment-parser/es6/parser/spec-parser.js\nfunction getParser3({\n  tokenizers\n}) {\n  return function (source) {\n    var _a;\n    let spec = seedSpec({\n      source\n    });\n    for (let tokenize of tokenizers) if (spec = tokenize(spec), !((_a = spec.problems[spec.problems.length - 1]) === null || _a === void 0) && _a.critical) break;\n    return spec;\n  };\n}\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/tag.js\nfunction tagTokenizer() {\n  return spec => {\n    let {\n        tokens\n      } = spec.source[0],\n      match = tokens.description.match(/\\s*(@(\\S+))(\\s*)/);\n    return match === null ? (spec.problems.push({\n      code: \"spec:tag:prefix\",\n      message: 'tag should start with \"@\" symbol',\n      line: spec.source[0].number,\n      critical: !0\n    }), spec) : (tokens.tag = match[1], tokens.postTag = match[3], tokens.description = tokens.description.slice(match[0].length), spec.tag = match[2], spec);\n  };\n}\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/type.js\nfunction typeTokenizer(spacing = \"compact\") {\n  let join2 = getJoiner(spacing);\n  return spec => {\n    let curlies = 0,\n      lines = [];\n    for (let [i, {\n      tokens\n    }] of spec.source.entries()) {\n      let type = \"\";\n      if (i === 0 && tokens.description[0] !== \"{\") return spec;\n      for (let ch of tokens.description) if (ch === \"{\" && curlies++, ch === \"}\" && curlies--, type += ch, curlies === 0) break;\n      if (lines.push([tokens, type]), curlies === 0) break;\n    }\n    if (curlies !== 0) return spec.problems.push({\n      code: \"spec:type:unpaired-curlies\",\n      message: \"unpaired curlies\",\n      line: spec.source[0].number,\n      critical: !0\n    }), spec;\n    let parts = [],\n      offset = lines[0][0].postDelimiter.length;\n    for (let [i, [tokens, type]] of lines.entries()) tokens.type = type, i > 0 && (tokens.type = tokens.postDelimiter.slice(offset) + type, tokens.postDelimiter = tokens.postDelimiter.slice(0, offset)), [tokens.postType, tokens.description] = splitSpace(tokens.description.slice(type.length)), parts.push(tokens.type);\n    return parts[0] = parts[0].slice(1), parts[parts.length - 1] = parts[parts.length - 1].slice(0, -1), spec.type = join2(parts), spec;\n  };\n}\nvar trim = x => x.trim();\nfunction getJoiner(spacing) {\n  return spacing === \"compact\" ? t => t.map(trim).join(\"\") : spacing === \"preserve\" ? t => t.join(`\n`) : spacing;\n}\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/name.js\nvar isQuoted = s => s && s.startsWith('\"') && s.endsWith('\"');\nfunction nameTokenizer() {\n  let typeEnd = (num, {\n    tokens\n  }, i) => tokens.type === \"\" ? num : i;\n  return spec => {\n    let {\n        tokens\n      } = spec.source[spec.source.reduce(typeEnd, 0)],\n      source = tokens.description.trimLeft(),\n      quotedGroups = source.split('\"');\n    if (quotedGroups.length > 1 && quotedGroups[0] === \"\" && quotedGroups.length % 2 === 1) return spec.name = quotedGroups[1], tokens.name = `\"${quotedGroups[1]}\"`, [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length)), spec;\n    let brackets = 0,\n      name = \"\",\n      optional = !1,\n      defaultValue;\n    for (let ch of source) {\n      if (brackets === 0 && isSpace(ch)) break;\n      ch === \"[\" && brackets++, ch === \"]\" && brackets--, name += ch;\n    }\n    if (brackets !== 0) return spec.problems.push({\n      code: \"spec:name:unpaired-brackets\",\n      message: \"unpaired brackets\",\n      line: spec.source[0].number,\n      critical: !0\n    }), spec;\n    let nameToken = name;\n    if (name[0] === \"[\" && name[name.length - 1] === \"]\") {\n      optional = !0, name = name.slice(1, -1);\n      let parts = name.split(\"=\");\n      if (name = parts[0].trim(), parts[1] !== void 0 && (defaultValue = parts.slice(1).join(\"=\").trim()), name === \"\") return spec.problems.push({\n        code: \"spec:name:empty-name\",\n        message: \"empty name\",\n        line: spec.source[0].number,\n        critical: !0\n      }), spec;\n      if (defaultValue === \"\") return spec.problems.push({\n        code: \"spec:name:empty-default\",\n        message: \"empty default value\",\n        line: spec.source[0].number,\n        critical: !0\n      }), spec;\n      if (!isQuoted(defaultValue) && /=(?!>)/.test(defaultValue)) return spec.problems.push({\n        code: \"spec:name:invalid-default\",\n        message: \"invalid default value syntax\",\n        line: spec.source[0].number,\n        critical: !0\n      }), spec;\n    }\n    return spec.optional = optional, spec.name = name, tokens.name = nameToken, defaultValue !== void 0 && (spec.default = defaultValue), [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length)), spec;\n  };\n}\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/description.js\nfunction descriptionTokenizer(spacing = \"compact\", markers = Markers) {\n  let join2 = getJoiner2(spacing);\n  return spec => (spec.description = join2(spec.source, markers), spec);\n}\nfunction getJoiner2(spacing) {\n  return spacing === \"compact\" ? compactJoiner : spacing === \"preserve\" ? preserveJoiner : spacing;\n}\nfunction compactJoiner(lines, markers = Markers) {\n  return lines.map(({\n    tokens: {\n      description\n    }\n  }) => description.trim()).filter(description => description !== \"\").join(\" \");\n}\nvar lineNo = (num, {\n    tokens\n  }, i) => tokens.type === \"\" ? num : i,\n  getDescription = ({\n    tokens\n  }) => (tokens.delimiter === \"\" ? tokens.start : tokens.postDelimiter.slice(1)) + tokens.description;\nfunction preserveJoiner(lines, markers = Markers) {\n  if (lines.length === 0) return \"\";\n  lines[0].tokens.description === \"\" && lines[0].tokens.delimiter === markers.start && (lines = lines.slice(1));\n  let lastLine = lines[lines.length - 1];\n  return lastLine !== void 0 && lastLine.tokens.description === \"\" && lastLine.tokens.end.endsWith(markers.end) && (lines = lines.slice(0, -1)), lines = lines.slice(lines.reduce(lineNo, 0)), lines.map(getDescription).join(`\n`);\n}\n\n// ../node_modules/comment-parser/es6/parser/index.js\nfunction getParser4({\n  startLine = 0,\n  fence = \"```\",\n  spacing = \"compact\",\n  markers = Markers,\n  tokenizers = [tagTokenizer(), typeTokenizer(spacing), nameTokenizer(), descriptionTokenizer(spacing)]\n} = {}) {\n  if (startLine < 0 || startLine % 1 > 0) throw new Error(\"Invalid startLine\");\n  let parseSource = getParser2({\n      startLine,\n      markers\n    }),\n    parseBlock = getParser({\n      fence\n    }),\n    parseSpec = getParser3({\n      tokenizers\n    }),\n    joinDescription = getJoiner2(spacing);\n  return function (source) {\n    let blocks = [];\n    for (let line of splitLines(source)) {\n      let lines = parseSource(line);\n      if (lines === null) continue;\n      let sections = parseBlock(lines),\n        specs = sections.slice(1).map(parseSpec);\n      blocks.push({\n        description: joinDescription(sections[0], markers),\n        tags: specs,\n        source: lines,\n        problems: specs.reduce((acc, spec) => acc.concat(spec.problems), [])\n      });\n    }\n    return blocks;\n  };\n}\n\n// ../node_modules/comment-parser/es6/stringifier/index.js\nfunction join(tokens) {\n  return tokens.start + tokens.delimiter + tokens.postDelimiter + tokens.tag + tokens.postTag + tokens.type + tokens.postType + tokens.name + tokens.postName + tokens.description + tokens.end + tokens.lineEnd;\n}\nfunction getStringifier() {\n  return block => block.source.map(({\n    tokens\n  }) => join(tokens)).join(`\n`);\n}\n\n// ../node_modules/comment-parser/es6/stringifier/inspect.js\nvar zeroWidth = {\n  line: 0,\n  start: 0,\n  delimiter: 0,\n  postDelimiter: 0,\n  tag: 0,\n  postTag: 0,\n  name: 0,\n  postName: 0,\n  type: 0,\n  postType: 0,\n  description: 0,\n  end: 0,\n  lineEnd: 0\n};\nvar fields = Object.keys(zeroWidth);\n\n// ../node_modules/comment-parser/es6/index.js\nfunction parse(source, options = {}) {\n  return getParser4(options)(source);\n}\nvar stringify = getStringifier();\n\n// src/docs-tools/argTypes/jsdocParser.ts\nvar import_jsdoc_type_pratt_parser = __toESM(require_dist(), 1);\nfunction containsJsDoc(value) {\n  return value != null && value.includes(\"@\");\n}\nfunction parse2(content) {\n  let normalisedContent = `/**\n` + (content ?? \"\").split(`\n`).map(line => ` * ${line}`).join(`\n`) + `\n*/`,\n    ast = parse(normalisedContent, {\n      spacing: \"preserve\"\n    });\n  if (!ast || ast.length === 0) throw new Error(\"Cannot parse JSDoc tags.\");\n  return ast[0];\n}\nvar DEFAULT_OPTIONS = {\n    tags: [\"param\", \"arg\", \"argument\", \"returns\", \"ignore\", \"deprecated\"]\n  },\n  parseJsDoc = (value, options = DEFAULT_OPTIONS) => {\n    if (!containsJsDoc(value)) return {\n      includesJsDoc: !1,\n      ignore: !1\n    };\n    let jsDocAst = parse2(value),\n      extractedTags = extractJsDocTags(jsDocAst, options.tags);\n    return extractedTags.ignore ? {\n      includesJsDoc: !0,\n      ignore: !0\n    } : {\n      includesJsDoc: !0,\n      ignore: !1,\n      // Always use the parsed description to ensure JSDoc is removed from the description.\n      description: jsDocAst.description.trim(),\n      extractedTags\n    };\n  };\nfunction extractJsDocTags(ast, tags) {\n  let extractedTags = {\n    params: null,\n    deprecated: null,\n    returns: null,\n    ignore: !1\n  };\n  for (let tagSpec of ast.tags) if (!(tags !== void 0 && !tags.includes(tagSpec.tag))) if (tagSpec.tag === \"ignore\") {\n    extractedTags.ignore = !0;\n    break;\n  } else switch (tagSpec.tag) {\n    // arg & argument are aliases for param.\n    case \"param\":\n    case \"arg\":\n    case \"argument\":\n      {\n        let paramTag = extractParam(tagSpec);\n        paramTag != null && (extractedTags.params == null && (extractedTags.params = []), extractedTags.params.push(paramTag));\n        break;\n      }\n    case \"deprecated\":\n      {\n        let deprecatedTag = extractDeprecated(tagSpec);\n        deprecatedTag != null && (extractedTags.deprecated = deprecatedTag);\n        break;\n      }\n    case \"returns\":\n      {\n        let returnsTag = extractReturns(tagSpec);\n        returnsTag != null && (extractedTags.returns = returnsTag);\n        break;\n      }\n    default:\n      break;\n  }\n  return extractedTags;\n}\nfunction normaliseParamName(name) {\n  return name.replace(/[\\.-]$/, \"\");\n}\nfunction extractParam(tag) {\n  if (!tag.name || tag.name === \"-\") return null;\n  let type = extractType(tag.type);\n  return {\n    name: tag.name,\n    type,\n    description: normaliseDescription(tag.description),\n    getPrettyName: () => normaliseParamName(tag.name),\n    getTypeName: () => type ? extractTypeName(type) : null\n  };\n}\nfunction extractDeprecated(tag) {\n  return tag.name ? joinNameAndDescription(tag.name, tag.description) : null;\n}\nfunction joinNameAndDescription(name, desc) {\n  let joined = name === \"\" ? desc : `${name} ${desc}`;\n  return normaliseDescription(joined);\n}\nfunction normaliseDescription(text) {\n  let normalised = text.replace(/^- /g, \"\").trim();\n  return normalised === \"\" ? null : normalised;\n}\nfunction extractReturns(tag) {\n  let type = extractType(tag.type);\n  return type ? {\n    type,\n    description: joinNameAndDescription(tag.name, tag.description),\n    getTypeName: () => extractTypeName(type)\n  } : null;\n}\nvar jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)(),\n  originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;\njsdocStringifyRules.JsdocTypeAny = () => \"any\";\njsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;\njsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join(\"|\");\nfunction extractType(typeString) {\n  try {\n    return (0, import_jsdoc_type_pratt_parser.parse)(typeString, \"typescript\");\n  } catch {\n    return null;\n  }\n}\nfunction extractTypeName(type) {\n  return (0, import_jsdoc_type_pratt_parser.transform)(jsdocStringifyRules, type);\n}\n\n// src/docs-tools/argTypes/utils.ts\nvar MAX_TYPE_SUMMARY_LENGTH = 90,\n  MAX_DEFAULT_VALUE_SUMMARY_LENGTH = 50;\nfunction isTooLongForTypeSummary(value) {\n  return value.length > 90;\n}\nfunction isTooLongForDefaultValueSummary(value) {\n  return value.length > 50;\n}\nfunction createSummaryValue(summary, detail) {\n  return summary === detail ? {\n    summary\n  } : {\n    summary,\n    detail\n  };\n}\nvar normalizeNewlines = string => string.replace(/\\\\r\\\\n/g, \"\\\\n\");\n\n// src/docs-tools/argTypes/docgen/flow/createDefaultValue.ts\nfunction createDefaultValue(defaultValue, type) {\n  if (defaultValue != null) {\n    let {\n      value\n    } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) return isTooLongForDefaultValueSummary(value) ? createSummaryValue(type?.name, value) : createSummaryValue(value);\n  }\n  return null;\n}\n\n// src/docs-tools/argTypes/docgen/flow/createType.ts\nfunction generateUnionElement({\n  name,\n  value,\n  elements,\n  raw\n}) {\n  return value ?? (elements != null ? elements.map(generateUnionElement).join(\" | \") : raw ?? name);\n}\nfunction generateUnion({\n  name,\n  raw,\n  elements\n}) {\n  return elements != null ? createSummaryValue(elements.map(generateUnionElement).join(\" | \")) : raw != null ? createSummaryValue(raw.replace(/^\\|\\s*/, \"\")) : createSummaryValue(name);\n}\nfunction generateFuncSignature({\n  type,\n  raw\n}) {\n  return raw != null ? createSummaryValue(raw) : createSummaryValue(type);\n}\nfunction generateObjectSignature({\n  type,\n  raw\n}) {\n  return raw != null ? isTooLongForTypeSummary(raw) ? createSummaryValue(type, raw) : createSummaryValue(raw) : createSummaryValue(type);\n}\nfunction generateSignature(flowType) {\n  let {\n    type\n  } = flowType;\n  return type === \"object\" ? generateObjectSignature(flowType) : generateFuncSignature(flowType);\n}\nfunction generateDefault({\n  name,\n  raw\n}) {\n  return raw != null ? isTooLongForTypeSummary(raw) ? createSummaryValue(name, raw) : createSummaryValue(raw) : createSummaryValue(name);\n}\nfunction createType(type) {\n  if (type == null) return null;\n  switch (type.name) {\n    case \"union\" /* UNION */:\n      return generateUnion(type);\n    case \"signature\" /* SIGNATURE */:\n      return generateSignature(type);\n    default:\n      return generateDefault(type);\n  }\n}\n\n// src/docs-tools/argTypes/docgen/flow/createPropDef.ts\nvar createFlowPropDef = (propName, docgenInfo) => {\n  let {\n    flowType,\n    description,\n    required,\n    defaultValue\n  } = docgenInfo;\n  return {\n    name: propName,\n    type: createType(flowType),\n    required,\n    description,\n    defaultValue: createDefaultValue(defaultValue ?? null, flowType ?? null)\n  };\n};\n\n// src/docs-tools/argTypes/docgen/typeScript/createDefaultValue.ts\nfunction createDefaultValue2({\n  defaultValue\n}) {\n  if (defaultValue != null) {\n    let {\n      value\n    } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) return createSummaryValue(value);\n  }\n  return null;\n}\n\n// src/docs-tools/argTypes/docgen/typeScript/createType.ts\nfunction createType2({\n  tsType,\n  required\n}) {\n  if (tsType == null) return null;\n  let typeName = tsType.name;\n  return required || (typeName = typeName.replace(\" | undefined\", \"\")), createSummaryValue([\"Array\", \"Record\", \"signature\"].includes(tsType.name) ? tsType.raw : typeName);\n}\n\n// src/docs-tools/argTypes/docgen/typeScript/createPropDef.ts\nvar createTsPropDef = (propName, docgenInfo) => {\n  let {\n    description,\n    required\n  } = docgenInfo;\n  return {\n    name: propName,\n    type: createType2(docgenInfo),\n    required,\n    description,\n    defaultValue: createDefaultValue2(docgenInfo)\n  };\n};\n\n// src/docs-tools/argTypes/docgen/createPropDef.ts\nfunction createType3(type) {\n  return type != null ? createSummaryValue(type.name) : null;\n}\nfunction isReactDocgenTypescript(defaultValue) {\n  let {\n    computed,\n    func\n  } = defaultValue;\n  return typeof computed > \"u\" && typeof func > \"u\";\n}\nfunction isStringValued(type) {\n  return type ? type.name === \"string\" ? !0 : type.name === \"enum\" ? Array.isArray(type.value) && type.value.every(({\n    value: tv\n  }) => typeof tv == \"string\" && tv[0] === '\"' && tv[tv.length - 1] === '\"') : !1 : !1;\n}\nfunction createDefaultValue3(defaultValue, type) {\n  if (defaultValue != null) {\n    let {\n      value\n    } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) return isReactDocgenTypescript(defaultValue) && isStringValued(type) ? createSummaryValue(JSON.stringify(value)) : createSummaryValue(value);\n  }\n  return null;\n}\nfunction createBasicPropDef(name, type, docgenInfo) {\n  let {\n    description,\n    required,\n    defaultValue\n  } = docgenInfo;\n  return {\n    name,\n    type: createType3(type),\n    required,\n    description,\n    defaultValue: createDefaultValue3(defaultValue, type)\n  };\n}\nfunction applyJsDocResult(propDef, jsDocParsingResult) {\n  if (jsDocParsingResult?.includesJsDoc) {\n    let {\n      description,\n      extractedTags\n    } = jsDocParsingResult;\n    description != null && (propDef.description = jsDocParsingResult.description);\n    let value = {\n      ...extractedTags,\n      params: extractedTags?.params?.map(x => ({\n        name: x.getPrettyName(),\n        description: x.description\n      }))\n    };\n    Object.values(value).filter(Boolean).length > 0 && (propDef.jsDocTags = value);\n  }\n  return propDef;\n}\nvar javaScriptFactory = (propName, docgenInfo, jsDocParsingResult) => {\n    let propDef = createBasicPropDef(propName, docgenInfo.type, docgenInfo);\n    return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);\n  },\n  tsFactory = (propName, docgenInfo, jsDocParsingResult) => {\n    let propDef = createTsPropDef(propName, docgenInfo);\n    return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);\n  },\n  flowFactory = (propName, docgenInfo, jsDocParsingResult) => {\n    let propDef = createFlowPropDef(propName, docgenInfo);\n    return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);\n  },\n  unknownFactory = (propName, docgenInfo, jsDocParsingResult) => {\n    let propDef = createBasicPropDef(propName, {\n      name: \"unknown\"\n    }, docgenInfo);\n    return applyJsDocResult(propDef, jsDocParsingResult);\n  },\n  getPropDefFactory = typeSystem => {\n    switch (typeSystem) {\n      case \"JavaScript\" /* JAVASCRIPT */:\n        return javaScriptFactory;\n      case \"TypeScript\" /* TYPESCRIPT */:\n        return tsFactory;\n      case \"Flow\" /* FLOW */:\n        return flowFactory;\n      default:\n        return unknownFactory;\n    }\n  };\n\n// src/docs-tools/argTypes/docgen/extractDocgenProps.ts\nvar getTypeSystem = docgenInfo => docgenInfo.type != null ? \"JavaScript\" /* JAVASCRIPT */ : docgenInfo.flowType != null ? \"Flow\" /* FLOW */ : docgenInfo.tsType != null ? \"TypeScript\" /* TYPESCRIPT */ : \"Unknown\" /* UNKNOWN */,\n  extractComponentSectionArray = docgenSection => {\n    let typeSystem = getTypeSystem(docgenSection[0]),\n      createPropDef = getPropDefFactory(typeSystem);\n    return docgenSection.map(item => {\n      let sanitizedItem = item;\n      return item.type?.elements && (sanitizedItem = {\n        ...item,\n        type: {\n          ...item.type,\n          value: item.type.elements\n        }\n      }), extractProp(sanitizedItem.name, sanitizedItem, typeSystem, createPropDef);\n    });\n  },\n  extractComponentSectionObject = docgenSection => {\n    let docgenPropsKeys = Object.keys(docgenSection),\n      typeSystem = getTypeSystem(docgenSection[docgenPropsKeys[0]]),\n      createPropDef = getPropDefFactory(typeSystem);\n    return docgenPropsKeys.map(propName => {\n      let docgenInfo = docgenSection[propName];\n      return docgenInfo != null ? extractProp(propName, docgenInfo, typeSystem, createPropDef) : null;\n    }).filter(Boolean);\n  },\n  extractComponentProps = (component, section) => {\n    let docgenSection = getDocgenSection(component, section);\n    return isValidDocgenSection(docgenSection) ? Array.isArray(docgenSection) ? extractComponentSectionArray(docgenSection) : extractComponentSectionObject(docgenSection) : [];\n  };\nfunction extractProp(propName, docgenInfo, typeSystem, createPropDef) {\n  let jsDocParsingResult = parseJsDoc(docgenInfo.description);\n  return jsDocParsingResult.includesJsDoc && jsDocParsingResult.ignore ? null : {\n    propDef: createPropDef(propName, docgenInfo, jsDocParsingResult),\n    jsDocTags: jsDocParsingResult.extractedTags,\n    docgenInfo,\n    typeSystem\n  };\n}\nfunction extractComponentDescription(component) {\n  return component != null ? getDocgenDescription(component) : \"\";\n}\n\n// src/preview-api/modules/store/parameters.ts\nvar combineParameters = (...parameterSets) => {\n  let mergeKeys = {},\n    definedParametersSets = parameterSets.filter(Boolean),\n    combined = definedParametersSets.reduce((acc, parameters) => (Object.entries(parameters).forEach(([key, value]) => {\n      let existing = acc[key];\n      Array.isArray(value) || typeof existing > \"u\" ? acc[key] = value : isPlainObject(value) && isPlainObject(existing) ? mergeKeys[key] = !0 : typeof value < \"u\" && (acc[key] = value);\n    }), acc), {});\n  return Object.keys(mergeKeys).forEach(key => {\n    let mergeValues = definedParametersSets.filter(Boolean).map(p => p[key]).filter(value => typeof value < \"u\");\n    mergeValues.every(value => isPlainObject(value)) ? combined[key] = combineParameters(...mergeValues) : combined[key] = mergeValues[mergeValues.length - 1];\n  }), combined;\n};\n\n// src/docs-tools/argTypes/enhanceArgTypes.ts\nvar enhanceArgTypes = context => {\n  let {\n      component,\n      argTypes: userArgTypes,\n      parameters: {\n        docs = {}\n      }\n    } = context,\n    {\n      extractArgTypes\n    } = docs;\n  if (!extractArgTypes || !component) return userArgTypes;\n  let extractedArgTypes = extractArgTypes(component);\n  return extractedArgTypes ? combineParameters(extractedArgTypes, userArgTypes) : userArgTypes;\n};\n\n// src/docs-tools/shared.ts\nvar ADDON_ID = \"storybook/docs\",\n  PANEL_ID = `${ADDON_ID}/panel`,\n  PARAM_KEY = \"docs\",\n  SNIPPET_RENDERED = `${ADDON_ID}/snippet-rendered`,\n  SourceType = /* @__PURE__ */(SourceType2 => (SourceType2.AUTO = \"auto\", SourceType2.CODE = \"code\", SourceType2.DYNAMIC = \"dynamic\", SourceType2))(SourceType || {});\nexport { combineParameters, convert4 as convert, TypeSystem, isDefaultValueBlacklisted, str, hasDocgen, isValidDocgenSection, getDocgenSection, getDocgenDescription, parseJsDoc, MAX_TYPE_SUMMARY_LENGTH, MAX_DEFAULT_VALUE_SUMMARY_LENGTH, isTooLongForTypeSummary, isTooLongForDefaultValueSummary, createSummaryValue, normalizeNewlines, extractComponentSectionArray, extractComponentSectionObject, extractComponentProps, extractComponentDescription, enhanceArgTypes, ADDON_ID, PANEL_ID, PARAM_KEY, SNIPPET_RENDERED, SourceType };","map":{"version":3,"names":["mapValues","isPlainObject","__commonJS","__toESM","require_dist","../node_modules/jsdoc-type-pratt-parser/dist/index.js","exports","module","global","factory","define","amd","globalThis","self","jtpp","exports2","tokenToString","token","text","type","NoParsletFoundError","Error","constructor","Object","setPrototypeOf","prototype","getToken","EarlyEndOfParseError","UnexpectedTypeError","result","message","error","makePunctuationRule","startsWith","getQuoted","position","char","mark","escaped","length","slice","identifierStartRegex","RegExp","identifierContinueRegex","getIdentifier","test","numberRegex","getNumber","_a","_b","exec","identifierRule","value","makeKeyWordRule","prepends","stringValueRule","eofRule","numberRule","rules","breakingWhitespaceRegex","Lexer","create","current","read","next","previous","startOfLine","trim","rule","partial","assign","advance","assertRootResult","assertPlainKeyValueOrRootResult","assertPlainKeyValueResult","assertPlainKeyValueOrNameResult","assertNumberOrVariadicNameResult","element","assertArrayOrTupleResult","meta","brackets","isSquaredProperty","Precedence","Precedence2","ALL","PARAMETER_LIST","OBJECT","KEY_VALUE","INDEX_BRACKETS","UNION","INTERSECTION","PREFIX","INFIX","TUPLE","SYMBOL","OPTIONAL","NULLABLE","KEY_OF_TYPE_OF","FUNCTION","ARROW","ARRAY_BRACKETS","GENERIC","NAME_PATH","PARENTHESIS","SPECIAL_TYPES","Parser","grammar","textOrLexer","baseParser","_lexer","lexer","parse","parseType","precedence","parseIntermediateType","tryParslets","parseInfixIntermediateType","left","parslet","consume","types","Array","isArray","includes","acceptLexerState","parser","isQuestionMarkUnknownType","nullableParslet","composeParslet","options","curPrecedence","accept","parsePrefix","parseInfix","defineProperty","name","optionalParslet","numberParslet","parseFloat","parenthesisParslet","elements","specialTypesParslet","notNullableParslet","createParameterListParslet","allowTrailingComma","push","e","some","genericParslet","dot","objects","infer","left2","unionParslet","baseGrammar","createNamePathParslet","allowSquareBracketsOnAnyType","allowJsdocNamePaths","pathGrammar","pathGrammar2","pathType","pathParser","parsed","right","quote","toString","specialType","createNameParslet","allowedAdditionalTokens","stringValueParslet","createSpecialNamePathParslet","allowedTypes","allowed","type2","moduleParser","moduleResult","basePathGrammar","getParameters","parameters","map","p","getUnnamedParameters","createFunctionParslet","allowNamedParameters","allowNoReturnType","allowWithoutParenthesis","allowNewAsFunctionKeyword","newKeyword","hasParenthesis","arrow","parenthesis","key","join","returnType","createVariadicParslet","allowPostfix","allowEnclosingBrackets","squareBrackets","symbolParslet","arrayBracketsParslet","createObjectParslet","objectFieldGrammar","objectFieldGrammar2","allowKeyTypes","separator","fieldParser","field","optional","quote2","readonly","propertyIndent","createObjectFieldParslet","allowSquaredProperties","allowReadonly","allowOptional","readonlyProperty","parentParser","createKeyValueParslet","allowVariadic","variadic","jsdocBaseGrammar","jsdocGrammar","typeOfParslet","objectFieldGrammar$1","closureGrammar","assertsParslet","createTupleParslet","allowQuestionMark","typeList","keyOfParslet","importParslet","path","readonlyPropertyParslet","arrowFunctionParslet","genericArrowFunctionParslet","typeParameters","defaultValue","constraint","typeParameter","functionBase","intersectionParslet","predicateParslet","objectSquaredPropertyParslet","readonlyArrayParslet","conditionalParslet","extendsType","trueType","checksType","falseType","typescriptGrammar","parse3","expression","mode","tryParse","modes","transform","rules2","parseResult","aParseResult","notAvailableTransform","extractSpecialParams","source","params","param","this","new","applyPosition","target","stringifyRules2","JsdocTypeParenthesis","transform2","JsdocTypeKeyof","JsdocTypeFunction","stringified","JsdocTypeName","JsdocTypeTuple","JsdocTypeVariadic","JsdocTypeNamePath","JsdocTypeStringValue","JsdocTypeAny","JsdocTypeGeneric","transformed","JsdocTypeImport","JsdocTypeObjectField","JsdocTypeJsdocObjectField","JsdocTypeKeyValue","JsdocTypeSpecialNamePath","JsdocTypeNotNullable","JsdocTypeNull","JsdocTypeNullable","JsdocTypeNumber","JsdocTypeObject","JsdocTypeOptional","JsdocTypeSymbol","JsdocTypeTypeof","JsdocTypeUndefined","JsdocTypeUnion","JsdocTypeUnknown","JsdocTypeIntersection","JsdocTypeProperty","JsdocTypePredicate","JsdocTypeIndexSignature","JsdocTypeMappedType","JsdocTypeAsserts","JsdocTypeReadonlyArray","JsdocTypeAssertsPlain","JsdocTypeConditional","JsdocTypeTypeParameter","storedStringifyRules","stringify2","reservedWords","makeName","reservedWord","catharsisTransformRules","nullable","repeatable","applications","o","fields","leftResult","rightValue","joiner","trailingDots","catharsisTransform","getQuoteStyle","getMemberType","nestResults","results","jtpRules","syntax","entries","quoteStyle","string","specialParams","typeName","returns","subject","hasEventPrefix","owner","tModule","number","jtpTransform","identityTransformRules","visitorKeys","_traverse","node","parentNode","property","onEnter","onLeave","keysToVisit","traverse","stringify","stringifyRules","UnknownArgTypesError","isLiteral","toEnumOption","replace","convertSig","values","signature","properties","forEach","prop","convert","language","raw","base","every","QUOTE_REGEX","trimQuotes","str2","includesQuotes","parseLiteral","trimmedValue","Number","isNaN","SIGNATURE_REGEXP","convert2","computed","values2","v","indexOf","literalValues","split","JSON","otherVal","otherName","UnknownArgTypesError2","convertSig2","convert3","convert4","docgenInfo","tsType","flowType","err","console","TypeSystem","TypeSystem2","JAVASCRIPT","FLOW","TYPESCRIPT","UNKNOWN","BLACKLIST","isDefaultValueBlacklisted","x","str","obj","hasDocgen","component","__docgenInfo","isValidDocgenSection","docgenSection","keys","getDocgenSection","section","getDocgenDescription","description","Markers","Markers2","start","nostart","delim","end","isSpace","splitCR","matches","match","splitSpace","splitLines","seedSpec","spec","tag","problems","seedTokens","tokens","delimiter","postDelimiter","postTag","postName","postType","lineEnd","reTag","getParser","fence","fencer","getFencer","toggleFence","isFenced","sections","line","getParser2","startLine","markers","block","num","rest","isClosed","trimRight","endsWith","trimmed","getParser3","tokenizers","tokenize","critical","tagTokenizer","code","typeTokenizer","spacing","join2","getJoiner","curlies","lines","i","ch","parts","offset","t","isQuoted","s","nameTokenizer","typeEnd","reduce","trimLeft","quotedGroups","nameToken","default","descriptionTokenizer","getJoiner2","compactJoiner","preserveJoiner","filter","lineNo","getDescription","lastLine","getParser4","parseSource","parseBlock","parseSpec","joinDescription","blocks","specs","tags","acc","concat","getStringifier","zeroWidth","import_jsdoc_type_pratt_parser","containsJsDoc","parse2","content","normalisedContent","ast","DEFAULT_OPTIONS","parseJsDoc","includesJsDoc","ignore","jsDocAst","extractedTags","extractJsDocTags","deprecated","tagSpec","paramTag","extractParam","deprecatedTag","extractDeprecated","returnsTag","extractReturns","normaliseParamName","extractType","normaliseDescription","getPrettyName","getTypeName","extractTypeName","joinNameAndDescription","desc","joined","normalised","jsdocStringifyRules","originalJsdocStringifyObject","typeString","MAX_TYPE_SUMMARY_LENGTH","MAX_DEFAULT_VALUE_SUMMARY_LENGTH","isTooLongForTypeSummary","isTooLongForDefaultValueSummary","createSummaryValue","summary","detail","normalizeNewlines","createDefaultValue","generateUnionElement","generateUnion","generateFuncSignature","generateObjectSignature","generateSignature","generateDefault","createType","createFlowPropDef","propName","required","createDefaultValue2","createType2","createTsPropDef","createType3","isReactDocgenTypescript","func","isStringValued","tv","createDefaultValue3","createBasicPropDef","applyJsDocResult","propDef","jsDocParsingResult","Boolean","jsDocTags","javaScriptFactory","sbType","tsFactory","flowFactory","unknownFactory","getPropDefFactory","typeSystem","getTypeSystem","extractComponentSectionArray","createPropDef","item","sanitizedItem","extractProp","extractComponentSectionObject","docgenPropsKeys","extractComponentProps","extractComponentDescription","combineParameters","parameterSets","mergeKeys","definedParametersSets","combined","existing","mergeValues","enhanceArgTypes","context","argTypes","userArgTypes","docs","extractArgTypes","extractedArgTypes","ADDON_ID","PANEL_ID","PARAM_KEY","SNIPPET_RENDERED","SourceType","SourceType2","AUTO","CODE","DYNAMIC"],"sources":["/Users/pea/Desktop/work/my-workspace/node_modules/storybook/dist/_browser-chunks/chunk-VYJQ7RU5.js"],"sourcesContent":["import {\n  mapValues\n} from \"./chunk-AIOS4NGK.js\";\nimport {\n  isPlainObject\n} from \"./chunk-GFLS4VP3.js\";\nimport {\n  __commonJS,\n  __toESM\n} from \"./chunk-A242L54C.js\";\n\n// ../node_modules/jsdoc-type-pratt-parser/dist/index.js\nvar require_dist = __commonJS({\n  \"../node_modules/jsdoc-type-pratt-parser/dist/index.js\"(exports, module) {\n    (function(global, factory) {\n      typeof exports == \"object\" && typeof module < \"u\" ? factory(exports) : typeof define == \"function\" && define.amd ? define([\"exports\"], factory) : (global = typeof globalThis < \"u\" ? globalThis : global || self, factory(global.jtpp = {}));\n    })(exports, (function(exports2) {\n      \"use strict\";\n      function tokenToString(token) {\n        return token.text !== void 0 && token.text !== \"\" ? `'${token.type}' with value '${token.text}'` : `'${token.type}'`;\n      }\n      class NoParsletFoundError extends Error {\n        constructor(token) {\n          super(`No parslet found for token: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, NoParsletFoundError.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      }\n      class EarlyEndOfParseError extends Error {\n        constructor(token) {\n          super(`The parsing ended early. The next token was: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      }\n      class UnexpectedTypeError extends Error {\n        constructor(result, message) {\n          let error = `Unexpected type: '${result.type}'.`;\n          message !== void 0 && (error += ` Message: ${message}`), super(error), Object.setPrototypeOf(this, UnexpectedTypeError.prototype);\n        }\n      }\n      function makePunctuationRule(type) {\n        return (text) => text.startsWith(type) ? { type, text: type } : null;\n      }\n      function getQuoted(text) {\n        let position = 0, char, mark = text[0], escaped = !1;\n        if (mark !== \"'\" && mark !== '\"')\n          return null;\n        for (; position < text.length; ) {\n          if (position++, char = text[position], !escaped && char === mark) {\n            position++;\n            break;\n          }\n          escaped = !escaped && char === \"\\\\\";\n        }\n        if (char !== mark)\n          throw new Error(\"Unterminated String\");\n        return text.slice(0, position);\n      }\n      let identifierStartRegex = new RegExp(\"[$_\\\\p{ID_Start}]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\"), identifierContinueRegex = new RegExp(\"[$\\\\-\\\\p{ID_Continue}\\\\u200C\\\\u200D]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\");\n      function getIdentifier(text) {\n        let char = text[0];\n        if (!identifierStartRegex.test(char))\n          return null;\n        let position = 1;\n        do {\n          if (char = text[position], !identifierContinueRegex.test(char))\n            break;\n          position++;\n        } while (position < text.length);\n        return text.slice(0, position);\n      }\n      let numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n      function getNumber(text) {\n        var _a, _b;\n        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n      }\n      let identifierRule = (text) => {\n        let value = getIdentifier(text);\n        return value == null ? null : {\n          type: \"Identifier\",\n          text: value\n        };\n      };\n      function makeKeyWordRule(type) {\n        return (text) => {\n          if (!text.startsWith(type))\n            return null;\n          let prepends = text[type.length];\n          return prepends !== void 0 && identifierContinueRegex.test(prepends) ? null : {\n            type,\n            text: type\n          };\n        };\n      }\n      let stringValueRule = (text) => {\n        let value = getQuoted(text);\n        return value == null ? null : {\n          type: \"StringValue\",\n          text: value\n        };\n      }, eofRule = (text) => text.length > 0 ? null : {\n        type: \"EOF\",\n        text: \"\"\n      }, numberRule = (text) => {\n        let value = getNumber(text);\n        return value === null ? null : {\n          type: \"Number\",\n          text: value\n        };\n      }, rules = [\n        eofRule,\n        makePunctuationRule(\"=>\"),\n        makePunctuationRule(\"(\"),\n        makePunctuationRule(\")\"),\n        makePunctuationRule(\"{\"),\n        makePunctuationRule(\"}\"),\n        makePunctuationRule(\"[\"),\n        makePunctuationRule(\"]\"),\n        makePunctuationRule(\"|\"),\n        makePunctuationRule(\"&\"),\n        makePunctuationRule(\"<\"),\n        makePunctuationRule(\">\"),\n        makePunctuationRule(\",\"),\n        makePunctuationRule(\";\"),\n        makePunctuationRule(\"*\"),\n        makePunctuationRule(\"?\"),\n        makePunctuationRule(\"!\"),\n        makePunctuationRule(\"=\"),\n        makePunctuationRule(\":\"),\n        makePunctuationRule(\"...\"),\n        makePunctuationRule(\".\"),\n        makePunctuationRule(\"#\"),\n        makePunctuationRule(\"~\"),\n        makePunctuationRule(\"/\"),\n        makePunctuationRule(\"@\"),\n        makeKeyWordRule(\"undefined\"),\n        makeKeyWordRule(\"null\"),\n        makeKeyWordRule(\"function\"),\n        makeKeyWordRule(\"this\"),\n        makeKeyWordRule(\"new\"),\n        makeKeyWordRule(\"module\"),\n        makeKeyWordRule(\"event\"),\n        makeKeyWordRule(\"extends\"),\n        makeKeyWordRule(\"external\"),\n        makeKeyWordRule(\"infer\"),\n        makeKeyWordRule(\"typeof\"),\n        makeKeyWordRule(\"keyof\"),\n        makeKeyWordRule(\"readonly\"),\n        makeKeyWordRule(\"import\"),\n        makeKeyWordRule(\"is\"),\n        makeKeyWordRule(\"in\"),\n        makeKeyWordRule(\"asserts\"),\n        numberRule,\n        identifierRule,\n        stringValueRule\n      ], breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n      class Lexer {\n        static create(text) {\n          let current = this.read(text);\n          text = current.text;\n          let next = this.read(text);\n          return text = next.text, new Lexer(text, void 0, current.token, next.token);\n        }\n        constructor(text, previous, current, next) {\n          this.text = \"\", this.text = text, this.previous = previous, this.current = current, this.next = next;\n        }\n        static read(text, startOfLine = !1) {\n          startOfLine = startOfLine || breakingWhitespaceRegex.test(text), text = text.trim();\n          for (let rule of rules) {\n            let partial = rule(text);\n            if (partial !== null) {\n              let token = Object.assign(Object.assign({}, partial), { startOfLine });\n              return text = text.slice(token.text.length), { text, token };\n            }\n          }\n          throw new Error(\"Unexpected Token \" + text);\n        }\n        advance() {\n          let next = Lexer.read(this.text);\n          return new Lexer(next.text, this.current, this.next, next.token);\n        }\n      }\n      function assertRootResult(result) {\n        if (result === void 0)\n          throw new Error(\"Unexpected undefined\");\n        if (result.type === \"JsdocTypeKeyValue\" || result.type === \"JsdocTypeParameterList\" || result.type === \"JsdocTypeProperty\" || result.type === \"JsdocTypeReadonlyProperty\" || result.type === \"JsdocTypeObjectField\" || result.type === \"JsdocTypeJsdocObjectField\" || result.type === \"JsdocTypeIndexSignature\" || result.type === \"JsdocTypeMappedType\" || result.type === \"JsdocTypeTypeParameter\")\n          throw new UnexpectedTypeError(result);\n        return result;\n      }\n      function assertPlainKeyValueOrRootResult(result) {\n        return result.type === \"JsdocTypeKeyValue\" ? assertPlainKeyValueResult(result) : assertRootResult(result);\n      }\n      function assertPlainKeyValueOrNameResult(result) {\n        return result.type === \"JsdocTypeName\" ? result : assertPlainKeyValueResult(result);\n      }\n      function assertPlainKeyValueResult(result) {\n        if (result.type !== \"JsdocTypeKeyValue\")\n          throw new UnexpectedTypeError(result);\n        return result;\n      }\n      function assertNumberOrVariadicNameResult(result) {\n        var _a;\n        if (result.type === \"JsdocTypeVariadic\") {\n          if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === \"JsdocTypeName\")\n            return result;\n          throw new UnexpectedTypeError(result);\n        }\n        if (result.type !== \"JsdocTypeNumber\" && result.type !== \"JsdocTypeName\")\n          throw new UnexpectedTypeError(result);\n        return result;\n      }\n      function assertArrayOrTupleResult(result) {\n        if (result.type === \"JsdocTypeTuple\" || result.type === \"JsdocTypeGeneric\" && result.meta.brackets === \"square\")\n          return result;\n        throw new UnexpectedTypeError(result);\n      }\n      function isSquaredProperty(result) {\n        return result.type === \"JsdocTypeIndexSignature\" || result.type === \"JsdocTypeMappedType\";\n      }\n      var Precedence;\n      (function(Precedence2) {\n        Precedence2[Precedence2.ALL = 0] = \"ALL\", Precedence2[Precedence2.PARAMETER_LIST = 1] = \"PARAMETER_LIST\", Precedence2[Precedence2.OBJECT = 2] = \"OBJECT\", Precedence2[Precedence2.KEY_VALUE = 3] = \"KEY_VALUE\", Precedence2[Precedence2.INDEX_BRACKETS = 4] = \"INDEX_BRACKETS\", Precedence2[Precedence2.UNION = 5] = \"UNION\", Precedence2[Precedence2.INTERSECTION = 6] = \"INTERSECTION\", Precedence2[Precedence2.PREFIX = 7] = \"PREFIX\", Precedence2[Precedence2.INFIX = 8] = \"INFIX\", Precedence2[Precedence2.TUPLE = 9] = \"TUPLE\", Precedence2[Precedence2.SYMBOL = 10] = \"SYMBOL\", Precedence2[Precedence2.OPTIONAL = 11] = \"OPTIONAL\", Precedence2[Precedence2.NULLABLE = 12] = \"NULLABLE\", Precedence2[Precedence2.KEY_OF_TYPE_OF = 13] = \"KEY_OF_TYPE_OF\", Precedence2[Precedence2.FUNCTION = 14] = \"FUNCTION\", Precedence2[Precedence2.ARROW = 15] = \"ARROW\", Precedence2[Precedence2.ARRAY_BRACKETS = 16] = \"ARRAY_BRACKETS\", Precedence2[Precedence2.GENERIC = 17] = \"GENERIC\", Precedence2[Precedence2.NAME_PATH = 18] = \"NAME_PATH\", Precedence2[Precedence2.PARENTHESIS = 19] = \"PARENTHESIS\", Precedence2[Precedence2.SPECIAL_TYPES = 20] = \"SPECIAL_TYPES\";\n      })(Precedence || (Precedence = {}));\n      class Parser {\n        constructor(grammar, textOrLexer, baseParser) {\n          this.grammar = grammar, typeof textOrLexer == \"string\" ? this._lexer = Lexer.create(textOrLexer) : this._lexer = textOrLexer, this.baseParser = baseParser;\n        }\n        get lexer() {\n          return this._lexer;\n        }\n        /**\n         * Parses a given string and throws an error if the parse ended before the end of the string.\n         */\n        parse() {\n          let result = this.parseType(Precedence.ALL);\n          if (this.lexer.current.type !== \"EOF\")\n            throw new EarlyEndOfParseError(this.lexer.current);\n          return result;\n        }\n        /**\n         * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n         */\n        parseType(precedence) {\n          return assertRootResult(this.parseIntermediateType(precedence));\n        }\n        /**\n         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n         * to parse the state in the infix step.\n         */\n        parseIntermediateType(precedence) {\n          let result = this.tryParslets(null, precedence);\n          if (result === null)\n            throw new NoParsletFoundError(this.lexer.current);\n          return this.parseInfixIntermediateType(result, precedence);\n        }\n        /**\n         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n         * a result.\n         */\n        parseInfixIntermediateType(left, precedence) {\n          let result = this.tryParslets(left, precedence);\n          for (; result !== null; )\n            left = result, result = this.tryParslets(left, precedence);\n          return left;\n        }\n        /**\n         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n         */\n        tryParslets(left, precedence) {\n          for (let parslet of this.grammar) {\n            let result = parslet(this, precedence, left);\n            if (result !== null)\n              return result;\n          }\n          return null;\n        }\n        /**\n         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n         * advanced.\n         */\n        consume(types) {\n          return Array.isArray(types) || (types = [types]), types.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), !0) : !1;\n        }\n        acceptLexerState(parser) {\n          this._lexer = parser.lexer;\n        }\n      }\n      function isQuestionMarkUnknownType(next) {\n        return next === \"}\" || next === \"EOF\" || next === \"|\" || next === \",\" || next === \")\" || next === \">\";\n      }\n      let nullableParslet = (parser, precedence, left) => {\n        let type = parser.lexer.current.type, next = parser.lexer.next.type;\n        return left == null && type === \"?\" && !isQuestionMarkUnknownType(next) || left != null && type === \"?\" ? (parser.consume(\"?\"), left == null ? {\n          type: \"JsdocTypeNullable\",\n          element: parser.parseType(Precedence.NULLABLE),\n          meta: {\n            position: \"prefix\"\n          }\n        } : {\n          type: \"JsdocTypeNullable\",\n          element: assertRootResult(left),\n          meta: {\n            position: \"suffix\"\n          }\n        }) : null;\n      };\n      function composeParslet(options) {\n        let parslet = (parser, curPrecedence, left) => {\n          let type = parser.lexer.current.type, next = parser.lexer.next.type;\n          if (left === null) {\n            if (\"parsePrefix\" in options && options.accept(type, next))\n              return options.parsePrefix(parser);\n          } else if (\"parseInfix\" in options && options.precedence > curPrecedence && options.accept(type, next))\n            return options.parseInfix(parser, left);\n          return null;\n        };\n        return Object.defineProperty(parslet, \"name\", {\n          value: options.name\n        }), parslet;\n      }\n      let optionalParslet = composeParslet({\n        name: \"optionalParslet\",\n        accept: (type) => type === \"=\",\n        precedence: Precedence.OPTIONAL,\n        parsePrefix: (parser) => (parser.consume(\"=\"), {\n          type: \"JsdocTypeOptional\",\n          element: parser.parseType(Precedence.OPTIONAL),\n          meta: {\n            position: \"prefix\"\n          }\n        }),\n        parseInfix: (parser, left) => (parser.consume(\"=\"), {\n          type: \"JsdocTypeOptional\",\n          element: assertRootResult(left),\n          meta: {\n            position: \"suffix\"\n          }\n        })\n      }), numberParslet = composeParslet({\n        name: \"numberParslet\",\n        accept: (type) => type === \"Number\",\n        parsePrefix: (parser) => {\n          let value = parseFloat(parser.lexer.current.text);\n          return parser.consume(\"Number\"), {\n            type: \"JsdocTypeNumber\",\n            value\n          };\n        }\n      }), parenthesisParslet = composeParslet({\n        name: \"parenthesisParslet\",\n        accept: (type) => type === \"(\",\n        parsePrefix: (parser) => {\n          if (parser.consume(\"(\"), parser.consume(\")\"))\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements: []\n            };\n          let result = parser.parseIntermediateType(Precedence.ALL);\n          if (!parser.consume(\")\"))\n            throw new Error(\"Unterminated parenthesis\");\n          return result.type === \"JsdocTypeParameterList\" ? result : result.type === \"JsdocTypeKeyValue\" ? {\n            type: \"JsdocTypeParameterList\",\n            elements: [result]\n          } : {\n            type: \"JsdocTypeParenthesis\",\n            element: assertRootResult(result)\n          };\n        }\n      }), specialTypesParslet = composeParslet({\n        name: \"specialTypesParslet\",\n        accept: (type, next) => type === \"?\" && isQuestionMarkUnknownType(next) || type === \"null\" || type === \"undefined\" || type === \"*\",\n        parsePrefix: (parser) => {\n          if (parser.consume(\"null\"))\n            return {\n              type: \"JsdocTypeNull\"\n            };\n          if (parser.consume(\"undefined\"))\n            return {\n              type: \"JsdocTypeUndefined\"\n            };\n          if (parser.consume(\"*\"))\n            return {\n              type: \"JsdocTypeAny\"\n            };\n          if (parser.consume(\"?\"))\n            return {\n              type: \"JsdocTypeUnknown\"\n            };\n          throw new Error(\"Unacceptable token: \" + parser.lexer.current.text);\n        }\n      }), notNullableParslet = composeParslet({\n        name: \"notNullableParslet\",\n        accept: (type) => type === \"!\",\n        precedence: Precedence.NULLABLE,\n        parsePrefix: (parser) => (parser.consume(\"!\"), {\n          type: \"JsdocTypeNotNullable\",\n          element: parser.parseType(Precedence.NULLABLE),\n          meta: {\n            position: \"prefix\"\n          }\n        }),\n        parseInfix: (parser, left) => (parser.consume(\"!\"), {\n          type: \"JsdocTypeNotNullable\",\n          element: assertRootResult(left),\n          meta: {\n            position: \"suffix\"\n          }\n        })\n      });\n      function createParameterListParslet({ allowTrailingComma }) {\n        return composeParslet({\n          name: \"parameterListParslet\",\n          accept: (type) => type === \",\",\n          precedence: Precedence.PARAMETER_LIST,\n          parseInfix: (parser, left) => {\n            let elements = [\n              assertPlainKeyValueOrRootResult(left)\n            ];\n            parser.consume(\",\");\n            do\n              try {\n                let next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n                elements.push(assertPlainKeyValueOrRootResult(next));\n              } catch (e) {\n                if (e instanceof NoParsletFoundError)\n                  break;\n                throw e;\n              }\n            while (parser.consume(\",\"));\n            if (elements.length > 0 && elements.slice(0, -1).some((e) => e.type === \"JsdocTypeVariadic\"))\n              throw new Error(\"Only the last parameter may be a rest parameter\");\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements\n            };\n          }\n        });\n      }\n      let genericParslet = composeParslet({\n        name: \"genericParslet\",\n        accept: (type, next) => type === \"<\" || type === \".\" && next === \"<\",\n        precedence: Precedence.GENERIC,\n        parseInfix: (parser, left) => {\n          let dot = parser.consume(\".\");\n          parser.consume(\"<\");\n          let objects = [], infer = !1;\n          if (parser.consume(\"infer\")) {\n            infer = !0;\n            let left2 = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (left2.type !== \"JsdocTypeName\")\n              throw new UnexpectedTypeError(left2, \"A typescript asserts always has to have a name on the left side.\");\n            objects.push(left2);\n          } else\n            do\n              objects.push(parser.parseType(Precedence.PARAMETER_LIST));\n            while (parser.consume(\",\"));\n          if (!parser.consume(\">\"))\n            throw new Error(\"Unterminated generic parameter list\");\n          return Object.assign(Object.assign({ type: \"JsdocTypeGeneric\", left: assertRootResult(left), elements: objects }, infer ? { infer: !0 } : {}), { meta: {\n            brackets: \"angle\",\n            dot\n          } });\n        }\n      }), unionParslet = composeParslet({\n        name: \"unionParslet\",\n        accept: (type) => type === \"|\",\n        precedence: Precedence.UNION,\n        parseInfix: (parser, left) => {\n          parser.consume(\"|\");\n          let elements = [];\n          do\n            elements.push(parser.parseType(Precedence.UNION));\n          while (parser.consume(\"|\"));\n          return {\n            type: \"JsdocTypeUnion\",\n            elements: [assertRootResult(left), ...elements]\n          };\n        }\n      }), baseGrammar = [\n        nullableParslet,\n        optionalParslet,\n        numberParslet,\n        parenthesisParslet,\n        specialTypesParslet,\n        notNullableParslet,\n        createParameterListParslet({\n          allowTrailingComma: !0\n        }),\n        genericParslet,\n        unionParslet,\n        optionalParslet\n      ];\n      function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar: pathGrammar2 }) {\n        return function(parser, precedence, left) {\n          if (left == null || precedence >= Precedence.NAME_PATH)\n            return null;\n          let type = parser.lexer.current.type, next = parser.lexer.next.type;\n          if (!(type === \".\" && next !== \"<\" || type === \"[\" && (allowSquareBracketsOnAnyType || left.type === \"JsdocTypeName\") || allowJsdocNamePaths && (type === \"~\" || type === \"#\")))\n            return null;\n          let pathType, brackets = !1;\n          parser.consume(\".\") ? pathType = \"property\" : parser.consume(\"[\") ? (pathType = \"property-brackets\", brackets = !0) : parser.consume(\"~\") ? pathType = \"inner\" : (parser.consume(\"#\"), pathType = \"instance\");\n          let pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser, parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n          parser.acceptLexerState(pathParser);\n          let right;\n          switch (parsed.type) {\n            case \"JsdocTypeName\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value,\n                meta: {\n                  quote: void 0\n                }\n              };\n              break;\n            case \"JsdocTypeNumber\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value.toString(10),\n                meta: {\n                  quote: void 0\n                }\n              };\n              break;\n            case \"JsdocTypeStringValue\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value,\n                meta: {\n                  quote: parsed.meta.quote\n                }\n              };\n              break;\n            case \"JsdocTypeSpecialNamePath\":\n              if (parsed.specialType === \"event\")\n                right = parsed;\n              else\n                throw new UnexpectedTypeError(parsed, \"Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'\");\n              break;\n            default:\n              throw new UnexpectedTypeError(parsed, \"Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'\");\n          }\n          if (brackets && !parser.consume(\"]\")) {\n            let token = parser.lexer.current;\n            throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);\n          }\n          return {\n            type: \"JsdocTypeNamePath\",\n            left: assertRootResult(left),\n            right,\n            pathType\n          };\n        };\n      }\n      function createNameParslet({ allowedAdditionalTokens }) {\n        return composeParslet({\n          name: \"nameParslet\",\n          accept: (type) => type === \"Identifier\" || type === \"this\" || type === \"new\" || allowedAdditionalTokens.includes(type),\n          parsePrefix: (parser) => {\n            let { type, text } = parser.lexer.current;\n            return parser.consume(type), {\n              type: \"JsdocTypeName\",\n              value: text\n            };\n          }\n        });\n      }\n      let stringValueParslet = composeParslet({\n        name: \"stringValueParslet\",\n        accept: (type) => type === \"StringValue\",\n        parsePrefix: (parser) => {\n          let text = parser.lexer.current.text;\n          return parser.consume(\"StringValue\"), {\n            type: \"JsdocTypeStringValue\",\n            value: text.slice(1, -1),\n            meta: {\n              quote: text[0] === \"'\" ? \"single\" : \"double\"\n            }\n          };\n        }\n      });\n      function createSpecialNamePathParslet({ pathGrammar: pathGrammar2, allowedTypes }) {\n        return composeParslet({\n          name: \"specialNamePathParslet\",\n          accept: (type) => allowedTypes.includes(type),\n          parsePrefix: (parser) => {\n            let type = parser.lexer.current.type;\n            if (parser.consume(type), !parser.consume(\":\"))\n              return {\n                type: \"JsdocTypeName\",\n                value: type\n              };\n            let result, token = parser.lexer.current;\n            if (parser.consume(\"StringValue\"))\n              result = {\n                type: \"JsdocTypeSpecialNamePath\",\n                value: token.text.slice(1, -1),\n                specialType: type,\n                meta: {\n                  quote: token.text[0] === \"'\" ? \"single\" : \"double\"\n                }\n              };\n            else {\n              let value = \"\", allowed = [\"Identifier\", \"@\", \"/\"];\n              for (; allowed.some((type2) => parser.consume(type2)); )\n                value += token.text, token = parser.lexer.current;\n              result = {\n                type: \"JsdocTypeSpecialNamePath\",\n                value,\n                specialType: type,\n                meta: {\n                  quote: void 0\n                }\n              };\n            }\n            let moduleParser = new Parser(pathGrammar2, parser.lexer, parser), moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n            return parser.acceptLexerState(moduleParser), assertRootResult(moduleResult);\n          }\n        });\n      }\n      let basePathGrammar = [\n        createNameParslet({\n          allowedAdditionalTokens: [\"external\", \"module\"]\n        }),\n        stringValueParslet,\n        numberParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: !1,\n          allowJsdocNamePaths: !0,\n          pathGrammar: null\n        })\n      ], pathGrammar = [\n        ...basePathGrammar,\n        createSpecialNamePathParslet({\n          allowedTypes: [\"event\"],\n          pathGrammar: basePathGrammar\n        })\n      ];\n      function getParameters(value) {\n        let parameters;\n        if (value.type === \"JsdocTypeParameterList\")\n          parameters = value.elements;\n        else if (value.type === \"JsdocTypeParenthesis\")\n          parameters = [value.element];\n        else\n          throw new UnexpectedTypeError(value);\n        return parameters.map((p) => assertPlainKeyValueOrRootResult(p));\n      }\n      function getUnnamedParameters(value) {\n        let parameters = getParameters(value);\n        if (parameters.some((p) => p.type === \"JsdocTypeKeyValue\"))\n          throw new Error(\"No parameter should be named\");\n        return parameters;\n      }\n      function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {\n        return composeParslet({\n          name: \"functionParslet\",\n          accept: (type, next) => type === \"function\" || allowNewAsFunctionKeyword && type === \"new\" && next === \"(\",\n          parsePrefix: (parser) => {\n            let newKeyword = parser.consume(\"new\");\n            parser.consume(\"function\");\n            let hasParenthesis = parser.lexer.current.type === \"(\";\n            if (!hasParenthesis) {\n              if (!allowWithoutParenthesis)\n                throw new Error(\"function is missing parameter list\");\n              return {\n                type: \"JsdocTypeName\",\n                value: \"function\"\n              };\n            }\n            let result = {\n              type: \"JsdocTypeFunction\",\n              parameters: [],\n              arrow: !1,\n              constructor: newKeyword,\n              parenthesis: hasParenthesis\n            }, value = parser.parseIntermediateType(Precedence.FUNCTION);\n            if (allowNamedParameters === void 0)\n              result.parameters = getUnnamedParameters(value);\n            else {\n              if (newKeyword && value.type === \"JsdocTypeFunction\" && value.arrow)\n                return result = value, result.constructor = !0, result;\n              result.parameters = getParameters(value);\n              for (let p of result.parameters)\n                if (p.type === \"JsdocTypeKeyValue\" && !allowNamedParameters.includes(p.key))\n                  throw new Error(`only allowed named parameters are ${allowNamedParameters.join(\", \")} but got ${p.type}`);\n            }\n            if (parser.consume(\":\"))\n              result.returnType = parser.parseType(Precedence.PREFIX);\n            else if (!allowNoReturnType)\n              throw new Error(\"function is missing return type\");\n            return result;\n          }\n        });\n      }\n      function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {\n        return composeParslet({\n          name: \"variadicParslet\",\n          accept: (type) => type === \"...\",\n          precedence: Precedence.PREFIX,\n          parsePrefix: (parser) => {\n            parser.consume(\"...\");\n            let brackets = allowEnclosingBrackets && parser.consume(\"[\");\n            try {\n              let element = parser.parseType(Precedence.PREFIX);\n              if (brackets && !parser.consume(\"]\"))\n                throw new Error(\"Unterminated variadic type. Missing ']'\");\n              return {\n                type: \"JsdocTypeVariadic\",\n                element: assertRootResult(element),\n                meta: {\n                  position: \"prefix\",\n                  squareBrackets: brackets\n                }\n              };\n            } catch (e) {\n              if (e instanceof NoParsletFoundError) {\n                if (brackets)\n                  throw new Error(\"Empty square brackets for variadic are not allowed.\");\n                return {\n                  type: \"JsdocTypeVariadic\",\n                  meta: {\n                    position: void 0,\n                    squareBrackets: !1\n                  }\n                };\n              } else\n                throw e;\n            }\n          },\n          parseInfix: allowPostfix ? (parser, left) => (parser.consume(\"...\"), {\n            type: \"JsdocTypeVariadic\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\",\n              squareBrackets: !1\n            }\n          }) : void 0\n        });\n      }\n      let symbolParslet = composeParslet({\n        name: \"symbolParslet\",\n        accept: (type) => type === \"(\",\n        precedence: Precedence.SYMBOL,\n        parseInfix: (parser, left) => {\n          if (left.type !== \"JsdocTypeName\")\n            throw new Error(\"Symbol expects a name on the left side. (Reacting on '(')\");\n          parser.consume(\"(\");\n          let result = {\n            type: \"JsdocTypeSymbol\",\n            value: left.value\n          };\n          if (!parser.consume(\")\")) {\n            let next = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (result.element = assertNumberOrVariadicNameResult(next), !parser.consume(\")\"))\n              throw new Error(\"Symbol does not end after value\");\n          }\n          return result;\n        }\n      }), arrayBracketsParslet = composeParslet({\n        name: \"arrayBracketsParslet\",\n        precedence: Precedence.ARRAY_BRACKETS,\n        accept: (type, next) => type === \"[\" && next === \"]\",\n        parseInfix: (parser, left) => (parser.consume(\"[\"), parser.consume(\"]\"), {\n          type: \"JsdocTypeGeneric\",\n          left: {\n            type: \"JsdocTypeName\",\n            value: \"Array\"\n          },\n          elements: [\n            assertRootResult(left)\n          ],\n          meta: {\n            brackets: \"square\",\n            dot: !1\n          }\n        })\n      });\n      function createObjectParslet({ objectFieldGrammar: objectFieldGrammar2, allowKeyTypes }) {\n        return composeParslet({\n          name: \"objectParslet\",\n          accept: (type) => type === \"{\",\n          parsePrefix: (parser) => {\n            parser.consume(\"{\");\n            let result = {\n              type: \"JsdocTypeObject\",\n              meta: {\n                separator: \"comma\"\n              },\n              elements: []\n            };\n            if (!parser.consume(\"}\")) {\n              let separator, fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);\n              for (; ; ) {\n                fieldParser.acceptLexerState(parser);\n                let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n                parser.acceptLexerState(fieldParser), field === void 0 && allowKeyTypes && (field = parser.parseIntermediateType(Precedence.OBJECT));\n                let optional = !1;\n                if (field.type === \"JsdocTypeNullable\" && (optional = !0, field = field.element), field.type === \"JsdocTypeNumber\" || field.type === \"JsdocTypeName\" || field.type === \"JsdocTypeStringValue\") {\n                  let quote2;\n                  field.type === \"JsdocTypeStringValue\" && (quote2 = field.meta.quote), result.elements.push({\n                    type: \"JsdocTypeObjectField\",\n                    key: field.value.toString(),\n                    right: void 0,\n                    optional,\n                    readonly: !1,\n                    meta: {\n                      quote: quote2\n                    }\n                  });\n                } else if (field.type === \"JsdocTypeObjectField\" || field.type === \"JsdocTypeJsdocObjectField\")\n                  result.elements.push(field);\n                else\n                  throw new UnexpectedTypeError(field);\n                if (parser.lexer.current.startOfLine)\n                  separator = \"linebreak\", parser.consume(\",\") || parser.consume(\";\");\n                else if (parser.consume(\",\"))\n                  separator = \"comma\";\n                else if (parser.consume(\";\"))\n                  separator = \"semicolon\";\n                else\n                  break;\n                if (parser.lexer.current.type === \"}\")\n                  break;\n              }\n              if (result.meta.separator = separator ?? \"comma\", separator === \"linebreak\" && (result.meta.propertyIndent = \"  \"), !parser.consume(\"}\"))\n                throw new Error(\"Unterminated record type. Missing '}'\");\n            }\n            return result;\n          }\n        });\n      }\n      function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {\n        return composeParslet({\n          name: \"objectFieldParslet\",\n          precedence: Precedence.KEY_VALUE,\n          accept: (type) => type === \":\",\n          parseInfix: (parser, left) => {\n            var _a;\n            let optional = !1, readonlyProperty = !1;\n            allowOptional && left.type === \"JsdocTypeNullable\" && (optional = !0, left = left.element), allowReadonly && left.type === \"JsdocTypeReadonlyProperty\" && (readonlyProperty = !0, left = left.element);\n            let parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n            if (parentParser.acceptLexerState(parser), left.type === \"JsdocTypeNumber\" || left.type === \"JsdocTypeName\" || left.type === \"JsdocTypeStringValue\" || isSquaredProperty(left)) {\n              if (isSquaredProperty(left) && !allowSquaredProperties)\n                throw new UnexpectedTypeError(left);\n              parentParser.consume(\":\");\n              let quote2;\n              left.type === \"JsdocTypeStringValue\" && (quote2 = left.meta.quote);\n              let right = parentParser.parseType(Precedence.KEY_VALUE);\n              return parser.acceptLexerState(parentParser), {\n                type: \"JsdocTypeObjectField\",\n                key: isSquaredProperty(left) ? left : left.value.toString(),\n                right,\n                optional,\n                readonly: readonlyProperty,\n                meta: {\n                  quote: quote2\n                }\n              };\n            } else {\n              if (!allowKeyTypes)\n                throw new UnexpectedTypeError(left);\n              parentParser.consume(\":\");\n              let right = parentParser.parseType(Precedence.KEY_VALUE);\n              return parser.acceptLexerState(parentParser), {\n                type: \"JsdocTypeJsdocObjectField\",\n                left: assertRootResult(left),\n                right\n              };\n            }\n          }\n        });\n      }\n      function createKeyValueParslet({ allowOptional, allowVariadic }) {\n        return composeParslet({\n          name: \"keyValueParslet\",\n          precedence: Precedence.KEY_VALUE,\n          accept: (type) => type === \":\",\n          parseInfix: (parser, left) => {\n            let optional = !1, variadic = !1;\n            if (allowOptional && left.type === \"JsdocTypeNullable\" && (optional = !0, left = left.element), allowVariadic && left.type === \"JsdocTypeVariadic\" && left.element !== void 0 && (variadic = !0, left = left.element), left.type !== \"JsdocTypeName\")\n              throw new UnexpectedTypeError(left);\n            parser.consume(\":\");\n            let right = parser.parseType(Precedence.KEY_VALUE);\n            return {\n              type: \"JsdocTypeKeyValue\",\n              key: left.value,\n              right,\n              optional,\n              variadic\n            };\n          }\n        });\n      }\n      let jsdocBaseGrammar = [\n        ...baseGrammar,\n        createFunctionParslet({\n          allowWithoutParenthesis: !0,\n          allowNamedParameters: [\"this\", \"new\"],\n          allowNoReturnType: !0,\n          allowNewAsFunctionKeyword: !1\n        }),\n        stringValueParslet,\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\", \"external\", \"event\"],\n          pathGrammar\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: !0,\n          allowPostfix: !0\n        }),\n        createNameParslet({\n          allowedAdditionalTokens: [\"keyof\"]\n        }),\n        symbolParslet,\n        arrayBracketsParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: !1,\n          allowJsdocNamePaths: !0,\n          pathGrammar\n        })\n      ], jsdocGrammar = [\n        ...jsdocBaseGrammar,\n        createObjectParslet({\n          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n          // we leave out the object type deliberately\n          objectFieldGrammar: [\n            createNameParslet({\n              allowedAdditionalTokens: [\"typeof\", \"module\", \"in\"]\n            }),\n            createObjectFieldParslet({\n              allowSquaredProperties: !1,\n              allowKeyTypes: !0,\n              allowOptional: !1,\n              allowReadonly: !1\n            }),\n            ...jsdocBaseGrammar\n          ],\n          allowKeyTypes: !0\n        }),\n        createKeyValueParslet({\n          allowOptional: !0,\n          allowVariadic: !0\n        })\n      ], typeOfParslet = composeParslet({\n        name: \"typeOfParslet\",\n        accept: (type) => type === \"typeof\",\n        parsePrefix: (parser) => (parser.consume(\"typeof\"), {\n          type: \"JsdocTypeTypeof\",\n          element: parser.parseType(Precedence.KEY_OF_TYPE_OF)\n        })\n      }), objectFieldGrammar$1 = [\n        createNameParslet({\n          allowedAdditionalTokens: [\"typeof\", \"module\", \"keyof\", \"event\", \"external\", \"in\"]\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n          allowSquaredProperties: !1,\n          allowKeyTypes: !1,\n          allowOptional: !1,\n          allowReadonly: !1\n        })\n      ], closureGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n          allowKeyTypes: !1,\n          objectFieldGrammar: objectFieldGrammar$1\n        }),\n        createNameParslet({\n          allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n        }),\n        typeOfParslet,\n        createFunctionParslet({\n          allowWithoutParenthesis: !1,\n          allowNamedParameters: [\"this\", \"new\"],\n          allowNoReturnType: !0,\n          allowNewAsFunctionKeyword: !1\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: !1,\n          allowPostfix: !1\n        }),\n        // additional name parslet is needed for some special cases\n        createNameParslet({\n          allowedAdditionalTokens: [\"keyof\"]\n        }),\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\"],\n          pathGrammar\n        }),\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: !1,\n          allowJsdocNamePaths: !0,\n          pathGrammar\n        }),\n        createKeyValueParslet({\n          allowOptional: !1,\n          allowVariadic: !1\n        }),\n        symbolParslet\n      ], assertsParslet = composeParslet({\n        name: \"assertsParslet\",\n        accept: (type) => type === \"asserts\",\n        parsePrefix: (parser) => {\n          parser.consume(\"asserts\");\n          let left = parser.parseIntermediateType(Precedence.SYMBOL);\n          if (left.type !== \"JsdocTypeName\")\n            throw new UnexpectedTypeError(left, \"A typescript asserts always has to have a name on the left side.\");\n          return parser.consume(\"is\") ? {\n            type: \"JsdocTypeAsserts\",\n            left,\n            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n          } : {\n            type: \"JsdocTypeAssertsPlain\",\n            element: left\n          };\n        }\n      });\n      function createTupleParslet({ allowQuestionMark }) {\n        return composeParslet({\n          name: \"tupleParslet\",\n          accept: (type) => type === \"[\",\n          parsePrefix: (parser) => {\n            parser.consume(\"[\");\n            let result = {\n              type: \"JsdocTypeTuple\",\n              elements: []\n            };\n            if (parser.consume(\"]\"))\n              return result;\n            let typeList = parser.parseIntermediateType(Precedence.ALL);\n            if (typeList.type === \"JsdocTypeParameterList\" ? typeList.elements[0].type === \"JsdocTypeKeyValue\" ? result.elements = typeList.elements.map(assertPlainKeyValueResult) : result.elements = typeList.elements.map(assertRootResult) : typeList.type === \"JsdocTypeKeyValue\" ? result.elements = [assertPlainKeyValueResult(typeList)] : result.elements = [assertRootResult(typeList)], !parser.consume(\"]\"))\n              throw new Error(\"Unterminated '['\");\n            if (result.elements.some((e) => e.type === \"JsdocTypeUnknown\"))\n              throw new Error(\"Question mark in tuple not allowed\");\n            return result;\n          }\n        });\n      }\n      let keyOfParslet = composeParslet({\n        name: \"keyOfParslet\",\n        accept: (type) => type === \"keyof\",\n        parsePrefix: (parser) => (parser.consume(\"keyof\"), {\n          type: \"JsdocTypeKeyof\",\n          element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n        })\n      }), importParslet = composeParslet({\n        name: \"importParslet\",\n        accept: (type) => type === \"import\",\n        parsePrefix: (parser) => {\n          if (parser.consume(\"import\"), !parser.consume(\"(\"))\n            throw new Error(\"Missing parenthesis after import keyword\");\n          let path = parser.parseType(Precedence.PREFIX);\n          if (path.type !== \"JsdocTypeStringValue\")\n            throw new Error(\"Only string values are allowed as paths for imports\");\n          if (!parser.consume(\")\"))\n            throw new Error(\"Missing closing parenthesis after import keyword\");\n          return {\n            type: \"JsdocTypeImport\",\n            element: path\n          };\n        }\n      }), readonlyPropertyParslet = composeParslet({\n        name: \"readonlyPropertyParslet\",\n        accept: (type) => type === \"readonly\",\n        parsePrefix: (parser) => (parser.consume(\"readonly\"), {\n          type: \"JsdocTypeReadonlyProperty\",\n          element: parser.parseIntermediateType(Precedence.KEY_VALUE)\n        })\n      }), arrowFunctionParslet = composeParslet({\n        name: \"arrowFunctionParslet\",\n        precedence: Precedence.ARROW,\n        accept: (type) => type === \"=>\",\n        parseInfix: (parser, left) => (parser.consume(\"=>\"), {\n          type: \"JsdocTypeFunction\",\n          parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n          arrow: !0,\n          constructor: !1,\n          parenthesis: !0,\n          returnType: parser.parseType(Precedence.OBJECT)\n        })\n      }), genericArrowFunctionParslet = composeParslet({\n        name: \"genericArrowFunctionParslet\",\n        accept: (type) => type === \"<\",\n        parsePrefix: (parser) => {\n          let typeParameters = [];\n          parser.consume(\"<\");\n          do {\n            let defaultValue, name = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (name.type === \"JsdocTypeOptional\" && (name = name.element, defaultValue = parser.parseType(Precedence.SYMBOL)), name.type !== \"JsdocTypeName\")\n              throw new UnexpectedTypeError(name);\n            let constraint;\n            parser.consume(\"extends\") && (constraint = parser.parseType(Precedence.SYMBOL), constraint.type === \"JsdocTypeOptional\" && (constraint = constraint.element, defaultValue = parser.parseType(Precedence.SYMBOL)));\n            let typeParameter = {\n              type: \"JsdocTypeTypeParameter\",\n              name\n            };\n            if (constraint !== void 0 && (typeParameter.constraint = constraint), defaultValue !== void 0 && (typeParameter.defaultValue = defaultValue), typeParameters.push(typeParameter), parser.consume(\">\"))\n              break;\n          } while (parser.consume(\",\"));\n          let functionBase = parser.parseIntermediateType(Precedence.SYMBOL);\n          return functionBase.typeParameters = typeParameters, functionBase;\n        }\n      }), intersectionParslet = composeParslet({\n        name: \"intersectionParslet\",\n        accept: (type) => type === \"&\",\n        precedence: Precedence.INTERSECTION,\n        parseInfix: (parser, left) => {\n          parser.consume(\"&\");\n          let elements = [];\n          do\n            elements.push(parser.parseType(Precedence.INTERSECTION));\n          while (parser.consume(\"&\"));\n          return {\n            type: \"JsdocTypeIntersection\",\n            elements: [assertRootResult(left), ...elements]\n          };\n        }\n      }), predicateParslet = composeParslet({\n        name: \"predicateParslet\",\n        precedence: Precedence.INFIX,\n        accept: (type) => type === \"is\",\n        parseInfix: (parser, left) => {\n          if (left.type !== \"JsdocTypeName\")\n            throw new UnexpectedTypeError(left, \"A typescript predicate always has to have a name on the left side.\");\n          return parser.consume(\"is\"), {\n            type: \"JsdocTypePredicate\",\n            left,\n            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n          };\n        }\n      }), objectSquaredPropertyParslet = composeParslet({\n        name: \"objectSquareBracketPropertyParslet\",\n        accept: (type) => type === \"[\",\n        parsePrefix: (parser) => {\n          if (parser.baseParser === void 0)\n            throw new Error(\"Only allowed inside object grammar\");\n          parser.consume(\"[\");\n          let key = parser.lexer.current.text;\n          parser.consume(\"Identifier\");\n          let result;\n          if (parser.consume(\":\")) {\n            let parentParser = parser.baseParser;\n            parentParser.acceptLexerState(parser), result = {\n              type: \"JsdocTypeIndexSignature\",\n              key,\n              right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n            }, parser.acceptLexerState(parentParser);\n          } else if (parser.consume(\"in\")) {\n            let parentParser = parser.baseParser;\n            parentParser.acceptLexerState(parser), result = {\n              type: \"JsdocTypeMappedType\",\n              key,\n              right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n            }, parser.acceptLexerState(parentParser);\n          } else\n            throw new Error(\"Missing ':' or 'in' inside square bracketed property.\");\n          if (!parser.consume(\"]\"))\n            throw new Error(\"Unterminated square brackets\");\n          return result;\n        }\n      }), readonlyArrayParslet = composeParslet({\n        name: \"readonlyArrayParslet\",\n        accept: (type) => type === \"readonly\",\n        parsePrefix: (parser) => (parser.consume(\"readonly\"), {\n          type: \"JsdocTypeReadonlyArray\",\n          element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))\n        })\n      }), conditionalParslet = composeParslet({\n        name: \"conditionalParslet\",\n        precedence: Precedence.INFIX,\n        accept: (type) => type === \"extends\",\n        parseInfix: (parser, left) => {\n          parser.consume(\"extends\");\n          let extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element, trueType = parser.parseType(Precedence.INFIX);\n          return parser.consume(\":\"), {\n            type: \"JsdocTypeConditional\",\n            checksType: assertRootResult(left),\n            extendsType,\n            trueType,\n            falseType: parser.parseType(Precedence.INFIX)\n          };\n        }\n      }), objectFieldGrammar = [\n        readonlyPropertyParslet,\n        createNameParslet({\n          allowedAdditionalTokens: [\"typeof\", \"module\", \"keyof\", \"event\", \"external\", \"in\"]\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n          allowSquaredProperties: !0,\n          allowKeyTypes: !1,\n          allowOptional: !0,\n          allowReadonly: !0\n        }),\n        objectSquaredPropertyParslet\n      ], typescriptGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n          allowKeyTypes: !1,\n          objectFieldGrammar\n        }),\n        readonlyArrayParslet,\n        typeOfParslet,\n        keyOfParslet,\n        importParslet,\n        stringValueParslet,\n        createFunctionParslet({\n          allowWithoutParenthesis: !0,\n          allowNoReturnType: !1,\n          allowNamedParameters: [\"this\", \"new\", \"args\"],\n          allowNewAsFunctionKeyword: !0\n        }),\n        createTupleParslet({\n          allowQuestionMark: !1\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: !1,\n          allowPostfix: !1\n        }),\n        assertsParslet,\n        conditionalParslet,\n        createNameParslet({\n          allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n        }),\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\"],\n          pathGrammar\n        }),\n        arrayBracketsParslet,\n        arrowFunctionParslet,\n        genericArrowFunctionParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: !0,\n          allowJsdocNamePaths: !1,\n          pathGrammar\n        }),\n        intersectionParslet,\n        predicateParslet,\n        createKeyValueParslet({\n          allowVariadic: !0,\n          allowOptional: !0\n        })\n      ];\n      function parse3(expression, mode) {\n        switch (mode) {\n          case \"closure\":\n            return new Parser(closureGrammar, expression).parse();\n          case \"jsdoc\":\n            return new Parser(jsdocGrammar, expression).parse();\n          case \"typescript\":\n            return new Parser(typescriptGrammar, expression).parse();\n        }\n      }\n      function tryParse(expression, modes = [\"typescript\", \"closure\", \"jsdoc\"]) {\n        let error;\n        for (let mode of modes)\n          try {\n            return parse3(expression, mode);\n          } catch (e) {\n            error = e;\n          }\n        throw error;\n      }\n      function transform(rules2, parseResult) {\n        let rule = rules2[parseResult.type];\n        if (rule === void 0)\n          throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n        return rule(parseResult, (aParseResult) => transform(rules2, aParseResult));\n      }\n      function notAvailableTransform(parseResult) {\n        throw new Error(\"This transform is not available. Are you trying the correct parsing mode?\");\n      }\n      function extractSpecialParams(source) {\n        let result = {\n          params: []\n        };\n        for (let param of source.parameters)\n          param.type === \"JsdocTypeKeyValue\" ? param.key === \"this\" ? result.this = param.right : param.key === \"new\" ? result.new = param.right : result.params.push(param) : result.params.push(param);\n        return result;\n      }\n      function applyPosition(position, target, value) {\n        return position === \"prefix\" ? value + target : target + value;\n      }\n      function quote(value, quote2) {\n        switch (quote2) {\n          case \"double\":\n            return `\"${value}\"`;\n          case \"single\":\n            return `'${value}'`;\n          case void 0:\n            return value;\n        }\n      }\n      function stringifyRules2() {\n        return {\n          JsdocTypeParenthesis: (result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : \"\"})`,\n          JsdocTypeKeyof: (result, transform2) => `keyof ${transform2(result.element)}`,\n          JsdocTypeFunction: (result, transform2) => {\n            var _a;\n            if (result.arrow) {\n              if (result.returnType === void 0)\n                throw new Error(\"Arrow function needs a return type.\");\n              let stringified = `${result.typeParameters !== void 0 ? `<${(_a = result.typeParameters.map(transform2).join(\", \")) !== null && _a !== void 0 ? _a : \"\"}>` : \"\"}(${result.parameters.map(transform2).join(\", \")}) => ${transform2(result.returnType)}`;\n              return result.constructor && (stringified = \"new \" + stringified), stringified;\n            } else {\n              let stringified = result.constructor ? \"new\" : \"function\";\n              return result.parenthesis && (stringified += `(${result.parameters.map(transform2).join(\", \")})`, result.returnType !== void 0 && (stringified += `: ${transform2(result.returnType)}`)), stringified;\n            }\n          },\n          JsdocTypeName: (result) => result.value,\n          JsdocTypeTuple: (result, transform2) => `[${result.elements.map(transform2).join(\", \")}]`,\n          JsdocTypeVariadic: (result, transform2) => result.meta.position === void 0 ? \"...\" : applyPosition(result.meta.position, transform2(result.element), \"...\"),\n          JsdocTypeNamePath: (result, transform2) => {\n            let left = transform2(result.left), right = transform2(result.right);\n            switch (result.pathType) {\n              case \"inner\":\n                return `${left}~${right}`;\n              case \"instance\":\n                return `${left}#${right}`;\n              case \"property\":\n                return `${left}.${right}`;\n              case \"property-brackets\":\n                return `${left}[${right}]`;\n            }\n          },\n          JsdocTypeStringValue: (result) => quote(result.value, result.meta.quote),\n          JsdocTypeAny: () => \"*\",\n          JsdocTypeGeneric: (result, transform2) => {\n            if (result.meta.brackets === \"square\") {\n              let element = result.elements[0], transformed = transform2(element);\n              return element.type === \"JsdocTypeUnion\" || element.type === \"JsdocTypeIntersection\" ? `(${transformed})[]` : `${transformed}[]`;\n            } else\n              return `${transform2(result.left)}${result.meta.dot ? \".\" : \"\"}<${result.infer === !0 ? \"infer \" : \"\"}${result.elements.map(transform2).join(\", \")}>`;\n          },\n          JsdocTypeImport: (result, transform2) => `import(${transform2(result.element)})`,\n          JsdocTypeObjectField: (result, transform2) => {\n            let text = \"\";\n            return result.readonly && (text += \"readonly \"), typeof result.key == \"string\" ? text += quote(result.key, result.meta.quote) : text += transform2(result.key), result.optional && (text += \"?\"), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;\n          },\n          JsdocTypeJsdocObjectField: (result, transform2) => `${transform2(result.left)}: ${transform2(result.right)}`,\n          JsdocTypeKeyValue: (result, transform2) => {\n            let text = result.key;\n            return result.optional && (text += \"?\"), result.variadic && (text = \"...\" + text), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;\n          },\n          JsdocTypeSpecialNamePath: (result) => `${result.specialType}:${quote(result.value, result.meta.quote)}`,\n          JsdocTypeNotNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"!\"),\n          JsdocTypeNull: () => \"null\",\n          JsdocTypeNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"?\"),\n          JsdocTypeNumber: (result) => result.value.toString(),\n          JsdocTypeObject: (result, transform2) => {\n            var _a, _b;\n            return `{${(result.meta.separator === \"linebreak\" && result.elements.length > 1 ? `\n` + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : \"\") : \"\") + result.elements.map(transform2).join(result.meta.separator === \"comma\" ? \", \" : result.meta.separator === \"linebreak\" ? `\n` + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : \"\") : \"; \") + (result.meta.separator === \"linebreak\" && result.elements.length > 1 ? `\n` : \"\")}}`;\n          },\n          JsdocTypeOptional: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"=\"),\n          JsdocTypeSymbol: (result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : \"\"})`,\n          JsdocTypeTypeof: (result, transform2) => `typeof ${transform2(result.element)}`,\n          JsdocTypeUndefined: () => \"undefined\",\n          JsdocTypeUnion: (result, transform2) => result.elements.map(transform2).join(\" | \"),\n          JsdocTypeUnknown: () => \"?\",\n          JsdocTypeIntersection: (result, transform2) => result.elements.map(transform2).join(\" & \"),\n          JsdocTypeProperty: (result) => quote(result.value, result.meta.quote),\n          JsdocTypePredicate: (result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`,\n          JsdocTypeIndexSignature: (result, transform2) => `[${result.key}: ${transform2(result.right)}]`,\n          JsdocTypeMappedType: (result, transform2) => `[${result.key} in ${transform2(result.right)}]`,\n          JsdocTypeAsserts: (result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`,\n          JsdocTypeReadonlyArray: (result, transform2) => `readonly ${transform2(result.element)}`,\n          JsdocTypeAssertsPlain: (result, transform2) => `asserts ${transform2(result.element)}`,\n          JsdocTypeConditional: (result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`,\n          JsdocTypeTypeParameter: (result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : \"\"}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : \"\"}`\n        };\n      }\n      let storedStringifyRules = stringifyRules2();\n      function stringify2(result) {\n        return transform(storedStringifyRules, result);\n      }\n      let reservedWords = [\n        \"null\",\n        \"true\",\n        \"false\",\n        \"break\",\n        \"case\",\n        \"catch\",\n        \"class\",\n        \"const\",\n        \"continue\",\n        \"debugger\",\n        \"default\",\n        \"delete\",\n        \"do\",\n        \"else\",\n        \"export\",\n        \"extends\",\n        \"finally\",\n        \"for\",\n        \"function\",\n        \"if\",\n        \"import\",\n        \"in\",\n        \"instanceof\",\n        \"new\",\n        \"return\",\n        \"super\",\n        \"switch\",\n        \"this\",\n        \"throw\",\n        \"try\",\n        \"typeof\",\n        \"var\",\n        \"void\",\n        \"while\",\n        \"with\",\n        \"yield\"\n      ];\n      function makeName(value) {\n        let result = {\n          type: \"NameExpression\",\n          name: value\n        };\n        return reservedWords.includes(value) && (result.reservedWord = !0), result;\n      }\n      let catharsisTransformRules = {\n        JsdocTypeOptional: (result, transform2) => {\n          let transformed = transform2(result.element);\n          return transformed.optional = !0, transformed;\n        },\n        JsdocTypeNullable: (result, transform2) => {\n          let transformed = transform2(result.element);\n          return transformed.nullable = !0, transformed;\n        },\n        JsdocTypeNotNullable: (result, transform2) => {\n          let transformed = transform2(result.element);\n          return transformed.nullable = !1, transformed;\n        },\n        JsdocTypeVariadic: (result, transform2) => {\n          if (result.element === void 0)\n            throw new Error(\"dots without value are not allowed in catharsis mode\");\n          let transformed = transform2(result.element);\n          return transformed.repeatable = !0, transformed;\n        },\n        JsdocTypeAny: () => ({\n          type: \"AllLiteral\"\n        }),\n        JsdocTypeNull: () => ({\n          type: \"NullLiteral\"\n        }),\n        JsdocTypeStringValue: (result) => makeName(quote(result.value, result.meta.quote)),\n        JsdocTypeUndefined: () => ({\n          type: \"UndefinedLiteral\"\n        }),\n        JsdocTypeUnknown: () => ({\n          type: \"UnknownLiteral\"\n        }),\n        JsdocTypeFunction: (result, transform2) => {\n          let params = extractSpecialParams(result), transformed = {\n            type: \"FunctionType\",\n            params: params.params.map(transform2)\n          };\n          return params.this !== void 0 && (transformed.this = transform2(params.this)), params.new !== void 0 && (transformed.new = transform2(params.new)), result.returnType !== void 0 && (transformed.result = transform2(result.returnType)), transformed;\n        },\n        JsdocTypeGeneric: (result, transform2) => ({\n          type: \"TypeApplication\",\n          applications: result.elements.map((o) => transform2(o)),\n          expression: transform2(result.left)\n        }),\n        JsdocTypeSpecialNamePath: (result) => makeName(result.specialType + \":\" + quote(result.value, result.meta.quote)),\n        JsdocTypeName: (result) => result.value !== \"function\" ? makeName(result.value) : {\n          type: \"FunctionType\",\n          params: []\n        },\n        JsdocTypeNumber: (result) => makeName(result.value.toString()),\n        JsdocTypeObject: (result, transform2) => {\n          let transformed = {\n            type: \"RecordType\",\n            fields: []\n          };\n          for (let field of result.elements)\n            field.type !== \"JsdocTypeObjectField\" && field.type !== \"JsdocTypeJsdocObjectField\" ? transformed.fields.push({\n              type: \"FieldType\",\n              key: transform2(field),\n              value: void 0\n            }) : transformed.fields.push(transform2(field));\n          return transformed;\n        },\n        JsdocTypeObjectField: (result, transform2) => {\n          if (typeof result.key != \"string\")\n            throw new Error(\"Index signatures and mapped types are not supported\");\n          return {\n            type: \"FieldType\",\n            key: makeName(quote(result.key, result.meta.quote)),\n            value: result.right === void 0 ? void 0 : transform2(result.right)\n          };\n        },\n        JsdocTypeJsdocObjectField: (result, transform2) => ({\n          type: \"FieldType\",\n          key: transform2(result.left),\n          value: transform2(result.right)\n        }),\n        JsdocTypeUnion: (result, transform2) => ({\n          type: \"TypeUnion\",\n          elements: result.elements.map((e) => transform2(e))\n        }),\n        JsdocTypeKeyValue: (result, transform2) => ({\n          type: \"FieldType\",\n          key: makeName(result.key),\n          value: result.right === void 0 ? void 0 : transform2(result.right)\n        }),\n        JsdocTypeNamePath: (result, transform2) => {\n          let leftResult = transform2(result.left), rightValue;\n          result.right.type === \"JsdocTypeSpecialNamePath\" ? rightValue = transform2(result.right).name : rightValue = quote(result.right.value, result.right.meta.quote);\n          let joiner = result.pathType === \"inner\" ? \"~\" : result.pathType === \"instance\" ? \"#\" : \".\";\n          return makeName(`${leftResult.name}${joiner}${rightValue}`);\n        },\n        JsdocTypeSymbol: (result) => {\n          let value = \"\", element = result.element, trailingDots = !1;\n          return element?.type === \"JsdocTypeVariadic\" && (element.meta.position === \"prefix\" ? value = \"...\" : trailingDots = !0, element = element.element), element?.type === \"JsdocTypeName\" ? value += element.value : element?.type === \"JsdocTypeNumber\" && (value += element.value.toString()), trailingDots && (value += \"...\"), makeName(`${result.value}(${value})`);\n        },\n        JsdocTypeParenthesis: (result, transform2) => transform2(assertRootResult(result.element)),\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeImport: notAvailableTransform,\n        JsdocTypeKeyof: notAvailableTransform,\n        JsdocTypeTuple: notAvailableTransform,\n        JsdocTypeTypeof: notAvailableTransform,\n        JsdocTypeIntersection: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n      };\n      function catharsisTransform(result) {\n        return transform(catharsisTransformRules, result);\n      }\n      function getQuoteStyle(quote2) {\n        switch (quote2) {\n          case void 0:\n            return \"none\";\n          case \"single\":\n            return \"single\";\n          case \"double\":\n            return \"double\";\n        }\n      }\n      function getMemberType(type) {\n        switch (type) {\n          case \"inner\":\n            return \"INNER_MEMBER\";\n          case \"instance\":\n            return \"INSTANCE_MEMBER\";\n          case \"property\":\n            return \"MEMBER\";\n          case \"property-brackets\":\n            return \"MEMBER\";\n        }\n      }\n      function nestResults(type, results) {\n        return results.length === 2 ? {\n          type,\n          left: results[0],\n          right: results[1]\n        } : {\n          type,\n          left: results[0],\n          right: nestResults(type, results.slice(1))\n        };\n      }\n      let jtpRules = {\n        JsdocTypeOptional: (result, transform2) => ({\n          type: \"OPTIONAL\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_EQUAL_SIGN\" : \"SUFFIX_EQUALS_SIGN\"\n          }\n        }),\n        JsdocTypeNullable: (result, transform2) => ({\n          type: \"NULLABLE\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_QUESTION_MARK\" : \"SUFFIX_QUESTION_MARK\"\n          }\n        }),\n        JsdocTypeNotNullable: (result, transform2) => ({\n          type: \"NOT_NULLABLE\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_BANG\" : \"SUFFIX_BANG\"\n          }\n        }),\n        JsdocTypeVariadic: (result, transform2) => {\n          let transformed = {\n            type: \"VARIADIC\",\n            meta: {\n              syntax: result.meta.position === \"prefix\" ? \"PREFIX_DOTS\" : result.meta.position === \"suffix\" ? \"SUFFIX_DOTS\" : \"ONLY_DOTS\"\n            }\n          };\n          return result.element !== void 0 && (transformed.value = transform2(result.element)), transformed;\n        },\n        JsdocTypeName: (result) => ({\n          type: \"NAME\",\n          name: result.value\n        }),\n        JsdocTypeTypeof: (result, transform2) => ({\n          type: \"TYPE_QUERY\",\n          name: transform2(result.element)\n        }),\n        JsdocTypeTuple: (result, transform2) => ({\n          type: \"TUPLE\",\n          entries: result.elements.map(transform2)\n        }),\n        JsdocTypeKeyof: (result, transform2) => ({\n          type: \"KEY_QUERY\",\n          value: transform2(result.element)\n        }),\n        JsdocTypeImport: (result) => ({\n          type: \"IMPORT\",\n          path: {\n            type: \"STRING_VALUE\",\n            quoteStyle: getQuoteStyle(result.element.meta.quote),\n            string: result.element.value\n          }\n        }),\n        JsdocTypeUndefined: () => ({\n          type: \"NAME\",\n          name: \"undefined\"\n        }),\n        JsdocTypeAny: () => ({\n          type: \"ANY\"\n        }),\n        JsdocTypeFunction: (result, transform2) => {\n          let specialParams = extractSpecialParams(result), transformed = {\n            type: result.arrow ? \"ARROW\" : \"FUNCTION\",\n            params: specialParams.params.map((param) => {\n              if (param.type === \"JsdocTypeKeyValue\") {\n                if (param.right === void 0)\n                  throw new Error(\"Function parameter without ':' is not expected to be 'KEY_VALUE'\");\n                return {\n                  type: \"NAMED_PARAMETER\",\n                  name: param.key,\n                  typeName: transform2(param.right)\n                };\n              } else\n                return transform2(param);\n            }),\n            new: null,\n            returns: null\n          };\n          return specialParams.this !== void 0 ? transformed.this = transform2(specialParams.this) : result.arrow || (transformed.this = null), specialParams.new !== void 0 && (transformed.new = transform2(specialParams.new)), result.returnType !== void 0 && (transformed.returns = transform2(result.returnType)), transformed;\n        },\n        JsdocTypeGeneric: (result, transform2) => {\n          let transformed = {\n            type: \"GENERIC\",\n            subject: transform2(result.left),\n            objects: result.elements.map(transform2),\n            meta: {\n              syntax: result.meta.brackets === \"square\" ? \"SQUARE_BRACKET\" : result.meta.dot ? \"ANGLE_BRACKET_WITH_DOT\" : \"ANGLE_BRACKET\"\n            }\n          };\n          return result.meta.brackets === \"square\" && result.elements[0].type === \"JsdocTypeFunction\" && !result.elements[0].parenthesis && (transformed.objects[0] = {\n            type: \"NAME\",\n            name: \"function\"\n          }), transformed;\n        },\n        JsdocTypeObjectField: (result, transform2) => {\n          if (typeof result.key != \"string\")\n            throw new Error(\"Index signatures and mapped types are not supported\");\n          if (result.right === void 0)\n            return {\n              type: \"RECORD_ENTRY\",\n              key: result.key,\n              quoteStyle: getQuoteStyle(result.meta.quote),\n              value: null,\n              readonly: !1\n            };\n          let right = transform2(result.right);\n          return result.optional && (right = {\n            type: \"OPTIONAL\",\n            value: right,\n            meta: {\n              syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n            }\n          }), {\n            type: \"RECORD_ENTRY\",\n            key: result.key.toString(),\n            quoteStyle: getQuoteStyle(result.meta.quote),\n            value: right,\n            readonly: !1\n          };\n        },\n        JsdocTypeJsdocObjectField: () => {\n          throw new Error(\"Keys may not be typed in jsdoctypeparser.\");\n        },\n        JsdocTypeKeyValue: (result, transform2) => {\n          if (result.right === void 0)\n            return {\n              type: \"RECORD_ENTRY\",\n              key: result.key,\n              quoteStyle: \"none\",\n              value: null,\n              readonly: !1\n            };\n          let right = transform2(result.right);\n          return result.optional && (right = {\n            type: \"OPTIONAL\",\n            value: right,\n            meta: {\n              syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n            }\n          }), {\n            type: \"RECORD_ENTRY\",\n            key: result.key,\n            quoteStyle: \"none\",\n            value: right,\n            readonly: !1\n          };\n        },\n        JsdocTypeObject: (result, transform2) => {\n          let entries = [];\n          for (let field of result.elements)\n            (field.type === \"JsdocTypeObjectField\" || field.type === \"JsdocTypeJsdocObjectField\") && entries.push(transform2(field));\n          return {\n            type: \"RECORD\",\n            entries\n          };\n        },\n        JsdocTypeSpecialNamePath: (result) => {\n          if (result.specialType !== \"module\")\n            throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n          return {\n            type: \"MODULE\",\n            value: {\n              type: \"FILE_PATH\",\n              quoteStyle: getQuoteStyle(result.meta.quote),\n              path: result.value\n            }\n          };\n        },\n        JsdocTypeNamePath: (result, transform2) => {\n          let hasEventPrefix = !1, name, quoteStyle;\n          result.right.type === \"JsdocTypeSpecialNamePath\" && result.right.specialType === \"event\" ? (hasEventPrefix = !0, name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote)) : (name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote));\n          let transformed = {\n            type: getMemberType(result.pathType),\n            owner: transform2(result.left),\n            name,\n            quoteStyle,\n            hasEventPrefix\n          };\n          if (transformed.owner.type === \"MODULE\") {\n            let tModule = transformed.owner;\n            return transformed.owner = transformed.owner.value, tModule.value = transformed, tModule;\n          } else\n            return transformed;\n        },\n        JsdocTypeUnion: (result, transform2) => nestResults(\"UNION\", result.elements.map(transform2)),\n        JsdocTypeParenthesis: (result, transform2) => ({\n          type: \"PARENTHESIS\",\n          value: transform2(assertRootResult(result.element))\n        }),\n        JsdocTypeNull: () => ({\n          type: \"NAME\",\n          name: \"null\"\n        }),\n        JsdocTypeUnknown: () => ({\n          type: \"UNKNOWN\"\n        }),\n        JsdocTypeStringValue: (result) => ({\n          type: \"STRING_VALUE\",\n          quoteStyle: getQuoteStyle(result.meta.quote),\n          string: result.value\n        }),\n        JsdocTypeIntersection: (result, transform2) => nestResults(\"INTERSECTION\", result.elements.map(transform2)),\n        JsdocTypeNumber: (result) => ({\n          type: \"NUMBER_VALUE\",\n          number: result.value.toString()\n        }),\n        JsdocTypeSymbol: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n      };\n      function jtpTransform(result) {\n        return transform(jtpRules, result);\n      }\n      function identityTransformRules() {\n        return {\n          JsdocTypeIntersection: (result, transform2) => ({\n            type: \"JsdocTypeIntersection\",\n            elements: result.elements.map(transform2)\n          }),\n          JsdocTypeGeneric: (result, transform2) => ({\n            type: \"JsdocTypeGeneric\",\n            left: transform2(result.left),\n            elements: result.elements.map(transform2),\n            meta: {\n              dot: result.meta.dot,\n              brackets: result.meta.brackets\n            }\n          }),\n          JsdocTypeNullable: (result) => result,\n          JsdocTypeUnion: (result, transform2) => ({\n            type: \"JsdocTypeUnion\",\n            elements: result.elements.map(transform2)\n          }),\n          JsdocTypeUnknown: (result) => result,\n          JsdocTypeUndefined: (result) => result,\n          JsdocTypeTypeof: (result, transform2) => ({\n            type: \"JsdocTypeTypeof\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeSymbol: (result, transform2) => {\n            let transformed = {\n              type: \"JsdocTypeSymbol\",\n              value: result.value\n            };\n            return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;\n          },\n          JsdocTypeOptional: (result, transform2) => ({\n            type: \"JsdocTypeOptional\",\n            element: transform2(result.element),\n            meta: {\n              position: result.meta.position\n            }\n          }),\n          JsdocTypeObject: (result, transform2) => ({\n            type: \"JsdocTypeObject\",\n            meta: {\n              separator: \"comma\"\n            },\n            elements: result.elements.map(transform2)\n          }),\n          JsdocTypeNumber: (result) => result,\n          JsdocTypeNull: (result) => result,\n          JsdocTypeNotNullable: (result, transform2) => ({\n            type: \"JsdocTypeNotNullable\",\n            element: transform2(result.element),\n            meta: {\n              position: result.meta.position\n            }\n          }),\n          JsdocTypeSpecialNamePath: (result) => result,\n          JsdocTypeObjectField: (result, transform2) => ({\n            type: \"JsdocTypeObjectField\",\n            key: result.key,\n            right: result.right === void 0 ? void 0 : transform2(result.right),\n            optional: result.optional,\n            readonly: result.readonly,\n            meta: result.meta\n          }),\n          JsdocTypeJsdocObjectField: (result, transform2) => ({\n            type: \"JsdocTypeJsdocObjectField\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }),\n          JsdocTypeKeyValue: (result, transform2) => ({\n            type: \"JsdocTypeKeyValue\",\n            key: result.key,\n            right: result.right === void 0 ? void 0 : transform2(result.right),\n            optional: result.optional,\n            variadic: result.variadic\n          }),\n          JsdocTypeImport: (result, transform2) => ({\n            type: \"JsdocTypeImport\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeAny: (result) => result,\n          JsdocTypeStringValue: (result) => result,\n          JsdocTypeNamePath: (result) => result,\n          JsdocTypeVariadic: (result, transform2) => {\n            let transformed = {\n              type: \"JsdocTypeVariadic\",\n              meta: {\n                position: result.meta.position,\n                squareBrackets: result.meta.squareBrackets\n              }\n            };\n            return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;\n          },\n          JsdocTypeTuple: (result, transform2) => ({\n            type: \"JsdocTypeTuple\",\n            elements: result.elements.map(transform2)\n          }),\n          JsdocTypeName: (result) => result,\n          JsdocTypeFunction: (result, transform2) => {\n            let transformed = {\n              type: \"JsdocTypeFunction\",\n              arrow: result.arrow,\n              parameters: result.parameters.map(transform2),\n              constructor: result.constructor,\n              parenthesis: result.parenthesis\n            };\n            return result.returnType !== void 0 && (transformed.returnType = transform2(result.returnType)), transformed;\n          },\n          JsdocTypeKeyof: (result, transform2) => ({\n            type: \"JsdocTypeKeyof\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeParenthesis: (result, transform2) => ({\n            type: \"JsdocTypeParenthesis\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeProperty: (result) => result,\n          JsdocTypePredicate: (result, transform2) => ({\n            type: \"JsdocTypePredicate\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }),\n          JsdocTypeIndexSignature: (result, transform2) => ({\n            type: \"JsdocTypeIndexSignature\",\n            key: result.key,\n            right: transform2(result.right)\n          }),\n          JsdocTypeMappedType: (result, transform2) => ({\n            type: \"JsdocTypeMappedType\",\n            key: result.key,\n            right: transform2(result.right)\n          }),\n          JsdocTypeAsserts: (result, transform2) => ({\n            type: \"JsdocTypeAsserts\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }),\n          JsdocTypeReadonlyArray: (result, transform2) => ({\n            type: \"JsdocTypeReadonlyArray\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeAssertsPlain: (result, transform2) => ({\n            type: \"JsdocTypeAssertsPlain\",\n            element: transform2(result.element)\n          }),\n          JsdocTypeConditional: (result, transform2) => ({\n            type: \"JsdocTypeConditional\",\n            checksType: transform2(result.checksType),\n            extendsType: transform2(result.extendsType),\n            trueType: transform2(result.trueType),\n            falseType: transform2(result.falseType)\n          }),\n          JsdocTypeTypeParameter: (result, transform2) => ({\n            type: \"JsdocTypeTypeParameter\",\n            name: transform2(result.name),\n            constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,\n            defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0\n          })\n        };\n      }\n      let visitorKeys = {\n        JsdocTypeAny: [],\n        JsdocTypeFunction: [\"parameters\", \"returnType\"],\n        JsdocTypeGeneric: [\"left\", \"elements\"],\n        JsdocTypeImport: [],\n        JsdocTypeIndexSignature: [\"right\"],\n        JsdocTypeIntersection: [\"elements\"],\n        JsdocTypeKeyof: [\"element\"],\n        JsdocTypeKeyValue: [\"right\"],\n        JsdocTypeMappedType: [\"right\"],\n        JsdocTypeName: [],\n        JsdocTypeNamePath: [\"left\", \"right\"],\n        JsdocTypeNotNullable: [\"element\"],\n        JsdocTypeNull: [],\n        JsdocTypeNullable: [\"element\"],\n        JsdocTypeNumber: [],\n        JsdocTypeObject: [\"elements\"],\n        JsdocTypeObjectField: [\"right\"],\n        JsdocTypeJsdocObjectField: [\"left\", \"right\"],\n        JsdocTypeOptional: [\"element\"],\n        JsdocTypeParenthesis: [\"element\"],\n        JsdocTypeSpecialNamePath: [],\n        JsdocTypeStringValue: [],\n        JsdocTypeSymbol: [\"element\"],\n        JsdocTypeTuple: [\"elements\"],\n        JsdocTypeTypeof: [\"element\"],\n        JsdocTypeUndefined: [],\n        JsdocTypeUnion: [\"elements\"],\n        JsdocTypeUnknown: [],\n        JsdocTypeVariadic: [\"element\"],\n        JsdocTypeProperty: [],\n        JsdocTypePredicate: [\"left\", \"right\"],\n        JsdocTypeAsserts: [\"left\", \"right\"],\n        JsdocTypeReadonlyArray: [\"element\"],\n        JsdocTypeAssertsPlain: [\"element\"],\n        JsdocTypeConditional: [\"checksType\", \"extendsType\", \"trueType\", \"falseType\"],\n        JsdocTypeTypeParameter: [\"name\", \"constraint\", \"defaultValue\"]\n      };\n      function _traverse(node, parentNode, property, onEnter, onLeave) {\n        onEnter?.(node, parentNode, property);\n        let keysToVisit = visitorKeys[node.type];\n        for (let key of keysToVisit) {\n          let value = node[key];\n          if (value !== void 0)\n            if (Array.isArray(value))\n              for (let element of value)\n                _traverse(element, node, key, onEnter, onLeave);\n            else\n              _traverse(value, node, key, onEnter, onLeave);\n        }\n        onLeave?.(node, parentNode, property);\n      }\n      function traverse(node, onEnter, onLeave) {\n        _traverse(node, void 0, void 0, onEnter, onLeave);\n      }\n      exports2.catharsisTransform = catharsisTransform, exports2.identityTransformRules = identityTransformRules, exports2.jtpTransform = jtpTransform, exports2.parse = parse3, exports2.stringify = stringify2, exports2.stringifyRules = stringifyRules2, exports2.transform = transform, exports2.traverse = traverse, exports2.tryParse = tryParse, exports2.visitorKeys = visitorKeys;\n    }));\n  }\n});\n\n// src/docs-tools/argTypes/convert/flow/convert.ts\nimport { UnknownArgTypesError } from \"storybook/internal/preview-errors\";\nvar isLiteral = (type) => type.name === \"literal\", toEnumOption = (element) => element.value.replace(/['|\"]/g, \"\"), convertSig = (type) => {\n  switch (type.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      let values = {};\n      return type.signature.properties.forEach((prop) => {\n        values[prop.key] = convert(prop.value);\n      }), {\n        name: \"object\",\n        value: values\n      };\n    default:\n      throw new UnknownArgTypesError({ type, language: \"Flow\" });\n  }\n}, convert = (type) => {\n  let { name, raw } = type, base = {};\n  switch (typeof raw < \"u\" && (base.raw = raw), type.name) {\n    case \"literal\":\n      return { ...base, name: \"other\", value: type.value };\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\":\n      return { ...base, name };\n    case \"Array\":\n      return { ...base, name: \"array\", value: type.elements.map(convert) };\n    case \"signature\":\n      return { ...base, ...convertSig(type) };\n    case \"union\":\n      return type.elements?.every(isLiteral) ? { ...base, name: \"enum\", value: type.elements?.map(toEnumOption) } : { ...base, name, value: type.elements?.map(convert) };\n    case \"intersection\":\n      return { ...base, name, value: type.elements?.map(convert) };\n    default:\n      return { ...base, name: \"other\", value: name };\n  }\n};\n\n// src/docs-tools/argTypes/convert/utils.ts\nvar QUOTE_REGEX = /^['\"]|['\"]$/g, trimQuotes = (str2) => str2.replace(QUOTE_REGEX, \"\"), includesQuotes = (str2) => QUOTE_REGEX.test(str2), parseLiteral = (str2) => {\n  let trimmedValue = trimQuotes(str2);\n  return includesQuotes(str2) || Number.isNaN(Number(trimmedValue)) ? trimmedValue : Number(trimmedValue);\n};\n\n// src/docs-tools/argTypes/convert/proptypes/convert.ts\nvar SIGNATURE_REGEXP = /^\\(.*\\) => /, convert2 = (type) => {\n  let { name, raw, computed, value } = type, base = {};\n  switch (typeof raw < \"u\" && (base.raw = raw), name) {\n    case \"enum\": {\n      let values2 = computed ? value : value.map((v) => parseLiteral(v.value));\n      return { ...base, name, value: values2 };\n    }\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n      return { ...base, name };\n    case \"func\":\n      return { ...base, name: \"function\" };\n    case \"bool\":\n    case \"boolean\":\n      return { ...base, name: \"boolean\" };\n    case \"arrayOf\":\n    case \"array\":\n      return { ...base, name: \"array\", value: value && convert2(value) };\n    case \"object\":\n      return { ...base, name };\n    case \"objectOf\":\n      return { ...base, name, value: convert2(value) };\n    case \"shape\":\n    case \"exact\":\n      let values = mapValues(value, (field) => convert2(field));\n      return { ...base, name: \"object\", value: values };\n    case \"union\":\n      return { ...base, name: \"union\", value: value.map((v) => convert2(v)) };\n    case \"instanceOf\":\n    case \"element\":\n    case \"elementType\":\n    default: {\n      if (name?.indexOf(\"|\") > 0)\n        try {\n          let literalValues = name.split(\"|\").map((v) => JSON.parse(v));\n          return { ...base, name: \"enum\", value: literalValues };\n        } catch {\n        }\n      let otherVal = value ? `${name}(${value})` : name, otherName = SIGNATURE_REGEXP.test(name) ? \"function\" : \"other\";\n      return { ...base, name: otherName, value: otherVal };\n    }\n  }\n};\n\n// src/docs-tools/argTypes/convert/typescript/convert.ts\nimport { UnknownArgTypesError as UnknownArgTypesError2 } from \"storybook/internal/preview-errors\";\nvar convertSig2 = (type) => {\n  switch (type.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      let values = {};\n      return type.signature.properties.forEach((prop) => {\n        values[prop.key] = convert3(prop.value);\n      }), {\n        name: \"object\",\n        value: values\n      };\n    default:\n      throw new UnknownArgTypesError2({ type, language: \"Typescript\" });\n  }\n}, convert3 = (type) => {\n  let { name, raw } = type, base = {};\n  switch (typeof raw < \"u\" && (base.raw = raw), type.name) {\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\":\n      return { ...base, name };\n    case \"Array\":\n      return { ...base, name: \"array\", value: type.elements.map(convert3) };\n    case \"signature\":\n      return { ...base, ...convertSig2(type) };\n    case \"union\":\n      let result;\n      return type.elements?.every((element) => element.name === \"literal\") ? result = {\n        ...base,\n        name: \"enum\",\n        // @ts-expect-error fix types\n        value: type.elements?.map((v) => parseLiteral(v.value))\n      } : result = { ...base, name, value: type.elements?.map(convert3) }, result;\n    case \"intersection\":\n      return { ...base, name, value: type.elements?.map(convert3) };\n    default:\n      return { ...base, name: \"other\", value: name };\n  }\n};\n\n// src/docs-tools/argTypes/convert/index.ts\nvar convert4 = (docgenInfo) => {\n  let { type, tsType, flowType } = docgenInfo;\n  try {\n    if (type != null)\n      return convert2(type);\n    if (tsType != null)\n      return convert3(tsType);\n    if (flowType != null)\n      return convert(flowType);\n  } catch (err) {\n    console.error(err);\n  }\n  return null;\n};\n\n// src/docs-tools/argTypes/docgen/types.ts\nvar TypeSystem = /* @__PURE__ */ ((TypeSystem2) => (TypeSystem2.JAVASCRIPT = \"JavaScript\", TypeSystem2.FLOW = \"Flow\", TypeSystem2.TYPESCRIPT = \"TypeScript\", TypeSystem2.UNKNOWN = \"Unknown\", TypeSystem2))(TypeSystem || {});\n\n// src/docs-tools/argTypes/docgen/utils/defaultValue.ts\nvar BLACKLIST = [\"null\", \"undefined\"];\nfunction isDefaultValueBlacklisted(value) {\n  return BLACKLIST.some((x) => x === value);\n}\n\n// src/docs-tools/argTypes/docgen/utils/string.ts\nvar str = (obj) => {\n  if (!obj)\n    return \"\";\n  if (typeof obj == \"string\")\n    return obj;\n  throw new Error(`Description: expected string, got: ${JSON.stringify(obj)}`);\n};\n\n// src/docs-tools/argTypes/docgen/utils/docgenInfo.ts\nfunction hasDocgen(component) {\n  return !!component.__docgenInfo;\n}\nfunction isValidDocgenSection(docgenSection) {\n  return docgenSection != null && Object.keys(docgenSection).length > 0;\n}\nfunction getDocgenSection(component, section) {\n  return hasDocgen(component) ? component.__docgenInfo[section] : null;\n}\nfunction getDocgenDescription(component) {\n  return hasDocgen(component) ? str(component.__docgenInfo.description) : \"\";\n}\n\n// ../node_modules/comment-parser/es6/primitives.js\nvar Markers;\n(function(Markers2) {\n  Markers2.start = \"/**\", Markers2.nostart = \"/***\", Markers2.delim = \"*\", Markers2.end = \"*/\";\n})(Markers = Markers || (Markers = {}));\n\n// ../node_modules/comment-parser/es6/util.js\nfunction isSpace(source) {\n  return /^\\s+$/.test(source);\n}\nfunction splitCR(source) {\n  let matches = source.match(/\\r+$/);\n  return matches == null ? [\"\", source] : [source.slice(-matches[0].length), source.slice(0, -matches[0].length)];\n}\nfunction splitSpace(source) {\n  let matches = source.match(/^\\s+/);\n  return matches == null ? [\"\", source] : [source.slice(0, matches[0].length), source.slice(matches[0].length)];\n}\nfunction splitLines(source) {\n  return source.split(/\\n/);\n}\nfunction seedSpec(spec = {}) {\n  return Object.assign({ tag: \"\", name: \"\", type: \"\", optional: !1, description: \"\", problems: [], source: [] }, spec);\n}\nfunction seedTokens(tokens = {}) {\n  return Object.assign({ start: \"\", delimiter: \"\", postDelimiter: \"\", tag: \"\", postTag: \"\", name: \"\", postName: \"\", type: \"\", postType: \"\", description: \"\", end: \"\", lineEnd: \"\" }, tokens);\n}\n\n// ../node_modules/comment-parser/es6/parser/block-parser.js\nvar reTag = /^@\\S+/;\nfunction getParser({ fence = \"```\" } = {}) {\n  let fencer = getFencer(fence), toggleFence = (source, isFenced) => fencer(source) ? !isFenced : isFenced;\n  return function(source) {\n    let sections = [[]], isFenced = !1;\n    for (let line of source)\n      reTag.test(line.tokens.description) && !isFenced ? sections.push([line]) : sections[sections.length - 1].push(line), isFenced = toggleFence(line.tokens.description, isFenced);\n    return sections;\n  };\n}\nfunction getFencer(fence) {\n  return typeof fence == \"string\" ? (source) => source.split(fence).length % 2 === 0 : fence;\n}\n\n// ../node_modules/comment-parser/es6/parser/source-parser.js\nfunction getParser2({ startLine = 0, markers = Markers } = {}) {\n  let block = null, num = startLine;\n  return function(source) {\n    let rest = source, tokens = seedTokens();\n    if ([tokens.lineEnd, rest] = splitCR(rest), [tokens.start, rest] = splitSpace(rest), block === null && rest.startsWith(markers.start) && !rest.startsWith(markers.nostart) && (block = [], tokens.delimiter = rest.slice(0, markers.start.length), rest = rest.slice(markers.start.length), [tokens.postDelimiter, rest] = splitSpace(rest)), block === null)\n      return num++, null;\n    let isClosed = rest.trimRight().endsWith(markers.end);\n    if (tokens.delimiter === \"\" && rest.startsWith(markers.delim) && !rest.startsWith(markers.end) && (tokens.delimiter = markers.delim, rest = rest.slice(markers.delim.length), [tokens.postDelimiter, rest] = splitSpace(rest)), isClosed) {\n      let trimmed = rest.trimRight();\n      tokens.end = rest.slice(trimmed.length - markers.end.length), rest = trimmed.slice(0, -markers.end.length);\n    }\n    if (tokens.description = rest, block.push({ number: num, source, tokens }), num++, isClosed) {\n      let result = block.slice();\n      return block = null, result;\n    }\n    return null;\n  };\n}\n\n// ../node_modules/comment-parser/es6/parser/spec-parser.js\nfunction getParser3({ tokenizers }) {\n  return function(source) {\n    var _a;\n    let spec = seedSpec({ source });\n    for (let tokenize of tokenizers)\n      if (spec = tokenize(spec), !((_a = spec.problems[spec.problems.length - 1]) === null || _a === void 0) && _a.critical)\n        break;\n    return spec;\n  };\n}\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/tag.js\nfunction tagTokenizer() {\n  return (spec) => {\n    let { tokens } = spec.source[0], match = tokens.description.match(/\\s*(@(\\S+))(\\s*)/);\n    return match === null ? (spec.problems.push({\n      code: \"spec:tag:prefix\",\n      message: 'tag should start with \"@\" symbol',\n      line: spec.source[0].number,\n      critical: !0\n    }), spec) : (tokens.tag = match[1], tokens.postTag = match[3], tokens.description = tokens.description.slice(match[0].length), spec.tag = match[2], spec);\n  };\n}\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/type.js\nfunction typeTokenizer(spacing = \"compact\") {\n  let join2 = getJoiner(spacing);\n  return (spec) => {\n    let curlies = 0, lines = [];\n    for (let [i, { tokens }] of spec.source.entries()) {\n      let type = \"\";\n      if (i === 0 && tokens.description[0] !== \"{\")\n        return spec;\n      for (let ch of tokens.description)\n        if (ch === \"{\" && curlies++, ch === \"}\" && curlies--, type += ch, curlies === 0)\n          break;\n      if (lines.push([tokens, type]), curlies === 0)\n        break;\n    }\n    if (curlies !== 0)\n      return spec.problems.push({\n        code: \"spec:type:unpaired-curlies\",\n        message: \"unpaired curlies\",\n        line: spec.source[0].number,\n        critical: !0\n      }), spec;\n    let parts = [], offset = lines[0][0].postDelimiter.length;\n    for (let [i, [tokens, type]] of lines.entries())\n      tokens.type = type, i > 0 && (tokens.type = tokens.postDelimiter.slice(offset) + type, tokens.postDelimiter = tokens.postDelimiter.slice(0, offset)), [tokens.postType, tokens.description] = splitSpace(tokens.description.slice(type.length)), parts.push(tokens.type);\n    return parts[0] = parts[0].slice(1), parts[parts.length - 1] = parts[parts.length - 1].slice(0, -1), spec.type = join2(parts), spec;\n  };\n}\nvar trim = (x) => x.trim();\nfunction getJoiner(spacing) {\n  return spacing === \"compact\" ? (t) => t.map(trim).join(\"\") : spacing === \"preserve\" ? (t) => t.join(`\n`) : spacing;\n}\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/name.js\nvar isQuoted = (s) => s && s.startsWith('\"') && s.endsWith('\"');\nfunction nameTokenizer() {\n  let typeEnd = (num, { tokens }, i) => tokens.type === \"\" ? num : i;\n  return (spec) => {\n    let { tokens } = spec.source[spec.source.reduce(typeEnd, 0)], source = tokens.description.trimLeft(), quotedGroups = source.split('\"');\n    if (quotedGroups.length > 1 && quotedGroups[0] === \"\" && quotedGroups.length % 2 === 1)\n      return spec.name = quotedGroups[1], tokens.name = `\"${quotedGroups[1]}\"`, [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length)), spec;\n    let brackets = 0, name = \"\", optional = !1, defaultValue;\n    for (let ch of source) {\n      if (brackets === 0 && isSpace(ch))\n        break;\n      ch === \"[\" && brackets++, ch === \"]\" && brackets--, name += ch;\n    }\n    if (brackets !== 0)\n      return spec.problems.push({\n        code: \"spec:name:unpaired-brackets\",\n        message: \"unpaired brackets\",\n        line: spec.source[0].number,\n        critical: !0\n      }), spec;\n    let nameToken = name;\n    if (name[0] === \"[\" && name[name.length - 1] === \"]\") {\n      optional = !0, name = name.slice(1, -1);\n      let parts = name.split(\"=\");\n      if (name = parts[0].trim(), parts[1] !== void 0 && (defaultValue = parts.slice(1).join(\"=\").trim()), name === \"\")\n        return spec.problems.push({\n          code: \"spec:name:empty-name\",\n          message: \"empty name\",\n          line: spec.source[0].number,\n          critical: !0\n        }), spec;\n      if (defaultValue === \"\")\n        return spec.problems.push({\n          code: \"spec:name:empty-default\",\n          message: \"empty default value\",\n          line: spec.source[0].number,\n          critical: !0\n        }), spec;\n      if (!isQuoted(defaultValue) && /=(?!>)/.test(defaultValue))\n        return spec.problems.push({\n          code: \"spec:name:invalid-default\",\n          message: \"invalid default value syntax\",\n          line: spec.source[0].number,\n          critical: !0\n        }), spec;\n    }\n    return spec.optional = optional, spec.name = name, tokens.name = nameToken, defaultValue !== void 0 && (spec.default = defaultValue), [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length)), spec;\n  };\n}\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/description.js\nfunction descriptionTokenizer(spacing = \"compact\", markers = Markers) {\n  let join2 = getJoiner2(spacing);\n  return (spec) => (spec.description = join2(spec.source, markers), spec);\n}\nfunction getJoiner2(spacing) {\n  return spacing === \"compact\" ? compactJoiner : spacing === \"preserve\" ? preserveJoiner : spacing;\n}\nfunction compactJoiner(lines, markers = Markers) {\n  return lines.map(({ tokens: { description } }) => description.trim()).filter((description) => description !== \"\").join(\" \");\n}\nvar lineNo = (num, { tokens }, i) => tokens.type === \"\" ? num : i, getDescription = ({ tokens }) => (tokens.delimiter === \"\" ? tokens.start : tokens.postDelimiter.slice(1)) + tokens.description;\nfunction preserveJoiner(lines, markers = Markers) {\n  if (lines.length === 0)\n    return \"\";\n  lines[0].tokens.description === \"\" && lines[0].tokens.delimiter === markers.start && (lines = lines.slice(1));\n  let lastLine = lines[lines.length - 1];\n  return lastLine !== void 0 && lastLine.tokens.description === \"\" && lastLine.tokens.end.endsWith(markers.end) && (lines = lines.slice(0, -1)), lines = lines.slice(lines.reduce(lineNo, 0)), lines.map(getDescription).join(`\n`);\n}\n\n// ../node_modules/comment-parser/es6/parser/index.js\nfunction getParser4({ startLine = 0, fence = \"```\", spacing = \"compact\", markers = Markers, tokenizers = [\n  tagTokenizer(),\n  typeTokenizer(spacing),\n  nameTokenizer(),\n  descriptionTokenizer(spacing)\n] } = {}) {\n  if (startLine < 0 || startLine % 1 > 0)\n    throw new Error(\"Invalid startLine\");\n  let parseSource = getParser2({ startLine, markers }), parseBlock = getParser({ fence }), parseSpec = getParser3({ tokenizers }), joinDescription = getJoiner2(spacing);\n  return function(source) {\n    let blocks = [];\n    for (let line of splitLines(source)) {\n      let lines = parseSource(line);\n      if (lines === null)\n        continue;\n      let sections = parseBlock(lines), specs = sections.slice(1).map(parseSpec);\n      blocks.push({\n        description: joinDescription(sections[0], markers),\n        tags: specs,\n        source: lines,\n        problems: specs.reduce((acc, spec) => acc.concat(spec.problems), [])\n      });\n    }\n    return blocks;\n  };\n}\n\n// ../node_modules/comment-parser/es6/stringifier/index.js\nfunction join(tokens) {\n  return tokens.start + tokens.delimiter + tokens.postDelimiter + tokens.tag + tokens.postTag + tokens.type + tokens.postType + tokens.name + tokens.postName + tokens.description + tokens.end + tokens.lineEnd;\n}\nfunction getStringifier() {\n  return (block) => block.source.map(({ tokens }) => join(tokens)).join(`\n`);\n}\n\n// ../node_modules/comment-parser/es6/stringifier/inspect.js\nvar zeroWidth = {\n  line: 0,\n  start: 0,\n  delimiter: 0,\n  postDelimiter: 0,\n  tag: 0,\n  postTag: 0,\n  name: 0,\n  postName: 0,\n  type: 0,\n  postType: 0,\n  description: 0,\n  end: 0,\n  lineEnd: 0\n};\nvar fields = Object.keys(zeroWidth);\n\n// ../node_modules/comment-parser/es6/index.js\nfunction parse(source, options = {}) {\n  return getParser4(options)(source);\n}\nvar stringify = getStringifier();\n\n// src/docs-tools/argTypes/jsdocParser.ts\nvar import_jsdoc_type_pratt_parser = __toESM(require_dist(), 1);\nfunction containsJsDoc(value) {\n  return value != null && value.includes(\"@\");\n}\nfunction parse2(content) {\n  let normalisedContent = `/**\n` + (content ?? \"\").split(`\n`).map((line) => ` * ${line}`).join(`\n`) + `\n*/`, ast = parse(normalisedContent, {\n    spacing: \"preserve\"\n  });\n  if (!ast || ast.length === 0)\n    throw new Error(\"Cannot parse JSDoc tags.\");\n  return ast[0];\n}\nvar DEFAULT_OPTIONS = {\n  tags: [\"param\", \"arg\", \"argument\", \"returns\", \"ignore\", \"deprecated\"]\n}, parseJsDoc = (value, options = DEFAULT_OPTIONS) => {\n  if (!containsJsDoc(value))\n    return {\n      includesJsDoc: !1,\n      ignore: !1\n    };\n  let jsDocAst = parse2(value), extractedTags = extractJsDocTags(jsDocAst, options.tags);\n  return extractedTags.ignore ? {\n    includesJsDoc: !0,\n    ignore: !0\n  } : {\n    includesJsDoc: !0,\n    ignore: !1,\n    // Always use the parsed description to ensure JSDoc is removed from the description.\n    description: jsDocAst.description.trim(),\n    extractedTags\n  };\n};\nfunction extractJsDocTags(ast, tags) {\n  let extractedTags = {\n    params: null,\n    deprecated: null,\n    returns: null,\n    ignore: !1\n  };\n  for (let tagSpec of ast.tags)\n    if (!(tags !== void 0 && !tags.includes(tagSpec.tag)))\n      if (tagSpec.tag === \"ignore\") {\n        extractedTags.ignore = !0;\n        break;\n      } else\n        switch (tagSpec.tag) {\n          // arg & argument are aliases for param.\n          case \"param\":\n          case \"arg\":\n          case \"argument\": {\n            let paramTag = extractParam(tagSpec);\n            paramTag != null && (extractedTags.params == null && (extractedTags.params = []), extractedTags.params.push(paramTag));\n            break;\n          }\n          case \"deprecated\": {\n            let deprecatedTag = extractDeprecated(tagSpec);\n            deprecatedTag != null && (extractedTags.deprecated = deprecatedTag);\n            break;\n          }\n          case \"returns\": {\n            let returnsTag = extractReturns(tagSpec);\n            returnsTag != null && (extractedTags.returns = returnsTag);\n            break;\n          }\n          default:\n            break;\n        }\n  return extractedTags;\n}\nfunction normaliseParamName(name) {\n  return name.replace(/[\\.-]$/, \"\");\n}\nfunction extractParam(tag) {\n  if (!tag.name || tag.name === \"-\")\n    return null;\n  let type = extractType(tag.type);\n  return {\n    name: tag.name,\n    type,\n    description: normaliseDescription(tag.description),\n    getPrettyName: () => normaliseParamName(tag.name),\n    getTypeName: () => type ? extractTypeName(type) : null\n  };\n}\nfunction extractDeprecated(tag) {\n  return tag.name ? joinNameAndDescription(tag.name, tag.description) : null;\n}\nfunction joinNameAndDescription(name, desc) {\n  let joined = name === \"\" ? desc : `${name} ${desc}`;\n  return normaliseDescription(joined);\n}\nfunction normaliseDescription(text) {\n  let normalised = text.replace(/^- /g, \"\").trim();\n  return normalised === \"\" ? null : normalised;\n}\nfunction extractReturns(tag) {\n  let type = extractType(tag.type);\n  return type ? {\n    type,\n    description: joinNameAndDescription(tag.name, tag.description),\n    getTypeName: () => extractTypeName(type)\n  } : null;\n}\nvar jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)(), originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;\njsdocStringifyRules.JsdocTypeAny = () => \"any\";\njsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;\njsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join(\"|\");\nfunction extractType(typeString) {\n  try {\n    return (0, import_jsdoc_type_pratt_parser.parse)(typeString, \"typescript\");\n  } catch {\n    return null;\n  }\n}\nfunction extractTypeName(type) {\n  return (0, import_jsdoc_type_pratt_parser.transform)(jsdocStringifyRules, type);\n}\n\n// src/docs-tools/argTypes/utils.ts\nvar MAX_TYPE_SUMMARY_LENGTH = 90, MAX_DEFAULT_VALUE_SUMMARY_LENGTH = 50;\nfunction isTooLongForTypeSummary(value) {\n  return value.length > 90;\n}\nfunction isTooLongForDefaultValueSummary(value) {\n  return value.length > 50;\n}\nfunction createSummaryValue(summary, detail) {\n  return summary === detail ? { summary } : { summary, detail };\n}\nvar normalizeNewlines = (string) => string.replace(/\\\\r\\\\n/g, \"\\\\n\");\n\n// src/docs-tools/argTypes/docgen/flow/createDefaultValue.ts\nfunction createDefaultValue(defaultValue, type) {\n  if (defaultValue != null) {\n    let { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value))\n      return isTooLongForDefaultValueSummary(value) ? createSummaryValue(type?.name, value) : createSummaryValue(value);\n  }\n  return null;\n}\n\n// src/docs-tools/argTypes/docgen/flow/createType.ts\nfunction generateUnionElement({ name, value, elements, raw }) {\n  return value ?? (elements != null ? elements.map(generateUnionElement).join(\" | \") : raw ?? name);\n}\nfunction generateUnion({ name, raw, elements }) {\n  return elements != null ? createSummaryValue(elements.map(generateUnionElement).join(\" | \")) : raw != null ? createSummaryValue(raw.replace(/^\\|\\s*/, \"\")) : createSummaryValue(name);\n}\nfunction generateFuncSignature({ type, raw }) {\n  return raw != null ? createSummaryValue(raw) : createSummaryValue(type);\n}\nfunction generateObjectSignature({ type, raw }) {\n  return raw != null ? isTooLongForTypeSummary(raw) ? createSummaryValue(type, raw) : createSummaryValue(raw) : createSummaryValue(type);\n}\nfunction generateSignature(flowType) {\n  let { type } = flowType;\n  return type === \"object\" ? generateObjectSignature(flowType) : generateFuncSignature(flowType);\n}\nfunction generateDefault({ name, raw }) {\n  return raw != null ? isTooLongForTypeSummary(raw) ? createSummaryValue(name, raw) : createSummaryValue(raw) : createSummaryValue(name);\n}\nfunction createType(type) {\n  if (type == null)\n    return null;\n  switch (type.name) {\n    case \"union\" /* UNION */:\n      return generateUnion(type);\n    case \"signature\" /* SIGNATURE */:\n      return generateSignature(type);\n    default:\n      return generateDefault(type);\n  }\n}\n\n// src/docs-tools/argTypes/docgen/flow/createPropDef.ts\nvar createFlowPropDef = (propName, docgenInfo) => {\n  let { flowType, description, required, defaultValue } = docgenInfo;\n  return {\n    name: propName,\n    type: createType(flowType),\n    required,\n    description,\n    defaultValue: createDefaultValue(defaultValue ?? null, flowType ?? null)\n  };\n};\n\n// src/docs-tools/argTypes/docgen/typeScript/createDefaultValue.ts\nfunction createDefaultValue2({ defaultValue }) {\n  if (defaultValue != null) {\n    let { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value))\n      return createSummaryValue(value);\n  }\n  return null;\n}\n\n// src/docs-tools/argTypes/docgen/typeScript/createType.ts\nfunction createType2({ tsType, required }) {\n  if (tsType == null)\n    return null;\n  let typeName = tsType.name;\n  return required || (typeName = typeName.replace(\" | undefined\", \"\")), createSummaryValue(\n    [\"Array\", \"Record\", \"signature\"].includes(tsType.name) ? tsType.raw : typeName\n  );\n}\n\n// src/docs-tools/argTypes/docgen/typeScript/createPropDef.ts\nvar createTsPropDef = (propName, docgenInfo) => {\n  let { description, required } = docgenInfo;\n  return {\n    name: propName,\n    type: createType2(docgenInfo),\n    required,\n    description,\n    defaultValue: createDefaultValue2(docgenInfo)\n  };\n};\n\n// src/docs-tools/argTypes/docgen/createPropDef.ts\nfunction createType3(type) {\n  return type != null ? createSummaryValue(type.name) : null;\n}\nfunction isReactDocgenTypescript(defaultValue) {\n  let { computed, func } = defaultValue;\n  return typeof computed > \"u\" && typeof func > \"u\";\n}\nfunction isStringValued(type) {\n  return type ? type.name === \"string\" ? !0 : type.name === \"enum\" ? Array.isArray(type.value) && type.value.every(\n    ({ value: tv }) => typeof tv == \"string\" && tv[0] === '\"' && tv[tv.length - 1] === '\"'\n  ) : !1 : !1;\n}\nfunction createDefaultValue3(defaultValue, type) {\n  if (defaultValue != null) {\n    let { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value))\n      return isReactDocgenTypescript(defaultValue) && isStringValued(type) ? createSummaryValue(JSON.stringify(value)) : createSummaryValue(value);\n  }\n  return null;\n}\nfunction createBasicPropDef(name, type, docgenInfo) {\n  let { description, required, defaultValue } = docgenInfo;\n  return {\n    name,\n    type: createType3(type),\n    required,\n    description,\n    defaultValue: createDefaultValue3(defaultValue, type)\n  };\n}\nfunction applyJsDocResult(propDef, jsDocParsingResult) {\n  if (jsDocParsingResult?.includesJsDoc) {\n    let { description, extractedTags } = jsDocParsingResult;\n    description != null && (propDef.description = jsDocParsingResult.description);\n    let value = {\n      ...extractedTags,\n      params: extractedTags?.params?.map(\n        (x) => ({\n          name: x.getPrettyName(),\n          description: x.description\n        })\n      )\n    };\n    Object.values(value).filter(Boolean).length > 0 && (propDef.jsDocTags = value);\n  }\n  return propDef;\n}\nvar javaScriptFactory = (propName, docgenInfo, jsDocParsingResult) => {\n  let propDef = createBasicPropDef(propName, docgenInfo.type, docgenInfo);\n  return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);\n}, tsFactory = (propName, docgenInfo, jsDocParsingResult) => {\n  let propDef = createTsPropDef(propName, docgenInfo);\n  return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);\n}, flowFactory = (propName, docgenInfo, jsDocParsingResult) => {\n  let propDef = createFlowPropDef(propName, docgenInfo);\n  return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);\n}, unknownFactory = (propName, docgenInfo, jsDocParsingResult) => {\n  let propDef = createBasicPropDef(propName, { name: \"unknown\" }, docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, getPropDefFactory = (typeSystem) => {\n  switch (typeSystem) {\n    case \"JavaScript\" /* JAVASCRIPT */:\n      return javaScriptFactory;\n    case \"TypeScript\" /* TYPESCRIPT */:\n      return tsFactory;\n    case \"Flow\" /* FLOW */:\n      return flowFactory;\n    default:\n      return unknownFactory;\n  }\n};\n\n// src/docs-tools/argTypes/docgen/extractDocgenProps.ts\nvar getTypeSystem = (docgenInfo) => docgenInfo.type != null ? \"JavaScript\" /* JAVASCRIPT */ : docgenInfo.flowType != null ? \"Flow\" /* FLOW */ : docgenInfo.tsType != null ? \"TypeScript\" /* TYPESCRIPT */ : \"Unknown\" /* UNKNOWN */, extractComponentSectionArray = (docgenSection) => {\n  let typeSystem = getTypeSystem(docgenSection[0]), createPropDef = getPropDefFactory(typeSystem);\n  return docgenSection.map((item) => {\n    let sanitizedItem = item;\n    return item.type?.elements && (sanitizedItem = {\n      ...item,\n      type: {\n        ...item.type,\n        value: item.type.elements\n      }\n    }), extractProp(sanitizedItem.name, sanitizedItem, typeSystem, createPropDef);\n  });\n}, extractComponentSectionObject = (docgenSection) => {\n  let docgenPropsKeys = Object.keys(docgenSection), typeSystem = getTypeSystem(docgenSection[docgenPropsKeys[0]]), createPropDef = getPropDefFactory(typeSystem);\n  return docgenPropsKeys.map((propName) => {\n    let docgenInfo = docgenSection[propName];\n    return docgenInfo != null ? extractProp(propName, docgenInfo, typeSystem, createPropDef) : null;\n  }).filter(Boolean);\n}, extractComponentProps = (component, section) => {\n  let docgenSection = getDocgenSection(component, section);\n  return isValidDocgenSection(docgenSection) ? Array.isArray(docgenSection) ? extractComponentSectionArray(docgenSection) : extractComponentSectionObject(docgenSection) : [];\n};\nfunction extractProp(propName, docgenInfo, typeSystem, createPropDef) {\n  let jsDocParsingResult = parseJsDoc(docgenInfo.description);\n  return jsDocParsingResult.includesJsDoc && jsDocParsingResult.ignore ? null : {\n    propDef: createPropDef(propName, docgenInfo, jsDocParsingResult),\n    jsDocTags: jsDocParsingResult.extractedTags,\n    docgenInfo,\n    typeSystem\n  };\n}\nfunction extractComponentDescription(component) {\n  return component != null ? getDocgenDescription(component) : \"\";\n}\n\n// src/preview-api/modules/store/parameters.ts\nvar combineParameters = (...parameterSets) => {\n  let mergeKeys = {}, definedParametersSets = parameterSets.filter(Boolean), combined = definedParametersSets.reduce((acc, parameters) => (Object.entries(parameters).forEach(([key, value]) => {\n    let existing = acc[key];\n    Array.isArray(value) || typeof existing > \"u\" ? acc[key] = value : isPlainObject(value) && isPlainObject(existing) ? mergeKeys[key] = !0 : typeof value < \"u\" && (acc[key] = value);\n  }), acc), {});\n  return Object.keys(mergeKeys).forEach((key) => {\n    let mergeValues = definedParametersSets.filter(Boolean).map((p) => p[key]).filter((value) => typeof value < \"u\");\n    mergeValues.every((value) => isPlainObject(value)) ? combined[key] = combineParameters(...mergeValues) : combined[key] = mergeValues[mergeValues.length - 1];\n  }), combined;\n};\n\n// src/docs-tools/argTypes/enhanceArgTypes.ts\nvar enhanceArgTypes = (context) => {\n  let {\n    component,\n    argTypes: userArgTypes,\n    parameters: { docs = {} }\n  } = context, { extractArgTypes } = docs;\n  if (!extractArgTypes || !component)\n    return userArgTypes;\n  let extractedArgTypes = extractArgTypes(component);\n  return extractedArgTypes ? combineParameters(extractedArgTypes, userArgTypes) : userArgTypes;\n};\n\n// src/docs-tools/shared.ts\nvar ADDON_ID = \"storybook/docs\", PANEL_ID = `${ADDON_ID}/panel`, PARAM_KEY = \"docs\", SNIPPET_RENDERED = `${ADDON_ID}/snippet-rendered`, SourceType = /* @__PURE__ */ ((SourceType2) => (SourceType2.AUTO = \"auto\", SourceType2.CODE = \"code\", SourceType2.DYNAMIC = \"dynamic\", SourceType2))(SourceType || {});\n\nexport {\n  combineParameters,\n  convert4 as convert,\n  TypeSystem,\n  isDefaultValueBlacklisted,\n  str,\n  hasDocgen,\n  isValidDocgenSection,\n  getDocgenSection,\n  getDocgenDescription,\n  parseJsDoc,\n  MAX_TYPE_SUMMARY_LENGTH,\n  MAX_DEFAULT_VALUE_SUMMARY_LENGTH,\n  isTooLongForTypeSummary,\n  isTooLongForDefaultValueSummary,\n  createSummaryValue,\n  normalizeNewlines,\n  extractComponentSectionArray,\n  extractComponentSectionObject,\n  extractComponentProps,\n  extractComponentDescription,\n  enhanceArgTypes,\n  ADDON_ID,\n  PANEL_ID,\n  PARAM_KEY,\n  SNIPPET_RENDERED,\n  SourceType\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { CallStates, EVENTS } from \"../_browser-chunks/chunk-ZUWEVLDX.js\";\nimport { processError } from \"../_browser-chunks/chunk-RP5RXKFU.js\";\nimport \"../_browser-chunks/chunk-A242L54C.js\";\n\n// src/instrumenter/instrumenter.ts\nimport { once } from \"storybook/internal/client-logger\";\nimport { FORCE_REMOUNT, SET_CURRENT_STORY, STORY_RENDER_PHASE_CHANGED } from \"storybook/internal/core-events\";\nimport { global } from \"@storybook/global\";\n\n// src/instrumenter/preview-api.ts\nvar addons = globalThis.__STORYBOOK_ADDONS_PREVIEW;\n\n// src/instrumenter/instrumenter.ts\nvar alreadyCompletedException = new Error(\"This function ran after the play function completed. Did you forget to `await` it?\"),\n  isObject = o => Object.prototype.toString.call(o) === \"[object Object]\",\n  isModule = o => Object.prototype.toString.call(o) === \"[object Module]\",\n  isInstrumentable = o => {\n    if (!isObject(o) && !isModule(o)) return !1;\n    if (o.constructor === void 0) return !0;\n    let proto = o.constructor.prototype;\n    return !!isObject(proto);\n  },\n  construct = obj => {\n    try {\n      return new obj.constructor();\n    } catch {\n      return {};\n    }\n  },\n  getInitialState = () => ({\n    renderPhase: \"preparing\",\n    isDebugging: !1,\n    isPlaying: !1,\n    isLocked: !1,\n    cursor: 0,\n    calls: [],\n    shadowCalls: [],\n    callRefsByResult: /* @__PURE__ */new Map(),\n    chainedCallIds: /* @__PURE__ */new Set(),\n    ancestors: [],\n    playUntil: void 0,\n    resolvers: {},\n    syncTimeout: void 0\n  }),\n  getRetainedState = (state, isDebugging = !1) => {\n    let calls = (isDebugging ? state.shadowCalls : state.calls).filter(call => call.retain);\n    if (!calls.length) return;\n    let callRefsByResult = new Map(Array.from(state.callRefsByResult.entries()).filter(([, ref]) => ref.retain));\n    return {\n      cursor: calls.length,\n      calls,\n      callRefsByResult\n    };\n  },\n  Instrumenter = class {\n    constructor() {\n      this.detached = !1;\n      this.initialized = !1;\n      // State is tracked per story to deal with multiple stories on the same canvas (i.e. docs mode)\n      this.state = {};\n      this.loadParentWindowState = () => {\n        try {\n          this.state = global.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};\n        } catch {\n          this.detached = !0;\n        }\n      };\n      this.updateParentWindowState = () => {\n        try {\n          global.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;\n        } catch {\n          this.detached = !0;\n        }\n      };\n      this.loadParentWindowState();\n      let resetState = ({\n          storyId,\n          renderPhase,\n          isPlaying = !0,\n          isDebugging = !1\n        }) => {\n          let state = this.getState(storyId);\n          this.setState(storyId, {\n            ...getInitialState(),\n            ...getRetainedState(state, isDebugging),\n            renderPhase: renderPhase || state.renderPhase,\n            shadowCalls: isDebugging ? state.shadowCalls : [],\n            chainedCallIds: isDebugging ? state.chainedCallIds : /* @__PURE__ */new Set(),\n            playUntil: isDebugging ? state.playUntil : void 0,\n            isPlaying,\n            isDebugging\n          }), this.sync(storyId);\n        },\n        start = channel => ({\n          storyId,\n          playUntil\n        }) => {\n          this.getState(storyId).isDebugging || this.setState(storyId, ({\n            calls\n          }) => ({\n            calls: [],\n            shadowCalls: calls.map(call => ({\n              ...call,\n              status: \"waiting\" /* WAITING */\n            })),\n            isDebugging: !0\n          }));\n          let log = this.getLog(storyId);\n          this.setState(storyId, ({\n            shadowCalls\n          }) => {\n            if (playUntil || !log.length) return {\n              playUntil\n            };\n            let firstRowIndex = shadowCalls.findIndex(call => call.id === log[0].callId);\n            return {\n              playUntil: shadowCalls.slice(0, firstRowIndex).filter(call => call.interceptable && !call.ancestors?.length).slice(-1)[0]?.id\n            };\n          }), channel.emit(FORCE_REMOUNT, {\n            storyId,\n            isDebugging: !0\n          });\n        },\n        back = channel => ({\n          storyId\n        }) => {\n          let log = this.getLog(storyId).filter(call => !call.ancestors?.length),\n            last = log.reduceRight((res, item, index) => res >= 0 || item.status === \"waiting\" /* WAITING */ ? res : index, -1);\n          start(channel)({\n            storyId,\n            playUntil: log[last - 1]?.callId\n          });\n        },\n        goto = channel => ({\n          storyId,\n          callId\n        }) => {\n          let {\n              calls,\n              shadowCalls,\n              resolvers\n            } = this.getState(storyId),\n            call = calls.find(({\n              id\n            }) => id === callId),\n            shadowCall = shadowCalls.find(({\n              id\n            }) => id === callId);\n          if (!call && shadowCall && Object.values(resolvers).length > 0) {\n            let nextId = this.getLog(storyId).find(c => c.status === \"waiting\" /* WAITING */)?.callId;\n            shadowCall.id !== nextId && this.setState(storyId, {\n              playUntil: shadowCall.id\n            }), Object.values(resolvers).forEach(resolve => resolve());\n          } else start(channel)({\n            storyId,\n            playUntil: callId\n          });\n        },\n        next = channel => ({\n          storyId\n        }) => {\n          let {\n            resolvers\n          } = this.getState(storyId);\n          if (Object.values(resolvers).length > 0) Object.values(resolvers).forEach(resolve => resolve());else {\n            let nextId = this.getLog(storyId).find(c => c.status === \"waiting\" /* WAITING */)?.callId;\n            nextId ? start(channel)({\n              storyId,\n              playUntil: nextId\n            }) : end({\n              storyId\n            });\n          }\n        },\n        end = ({\n          storyId\n        }) => {\n          this.setState(storyId, {\n            playUntil: void 0,\n            isDebugging: !1\n          }), Object.values(this.getState(storyId).resolvers).forEach(resolve => resolve());\n        },\n        renderPhaseChanged = ({\n          storyId,\n          newPhase\n        }) => {\n          let {\n            isDebugging\n          } = this.getState(storyId);\n          if (newPhase === \"preparing\" && isDebugging) return resetState({\n            storyId,\n            renderPhase: newPhase,\n            isDebugging\n          });\n          if (newPhase === \"playing\") return resetState({\n            storyId,\n            renderPhase: newPhase,\n            isDebugging\n          });\n          newPhase === \"played\" ? this.setState(storyId, {\n            renderPhase: newPhase,\n            isLocked: !1,\n            isPlaying: !1,\n            isDebugging: !1\n          }) : newPhase === \"errored\" ? this.setState(storyId, {\n            renderPhase: newPhase,\n            isLocked: !1,\n            isPlaying: !1\n          }) : newPhase === \"aborted\" ? this.setState(storyId, {\n            renderPhase: newPhase,\n            isLocked: !0,\n            isPlaying: !1\n          }) : this.setState(storyId, {\n            renderPhase: newPhase\n          }), this.sync(storyId);\n        };\n      addons && addons.ready().then(() => {\n        this.channel = addons.getChannel(), this.channel.on(FORCE_REMOUNT, resetState), this.channel.on(STORY_RENDER_PHASE_CHANGED, renderPhaseChanged), this.channel.on(SET_CURRENT_STORY, () => {\n          this.initialized ? this.cleanup() : this.initialized = !0;\n        }), this.channel.on(EVENTS.START, start(this.channel)), this.channel.on(EVENTS.BACK, back(this.channel)), this.channel.on(EVENTS.GOTO, goto(this.channel)), this.channel.on(EVENTS.NEXT, next(this.channel)), this.channel.on(EVENTS.END, end);\n      });\n    }\n    getState(storyId) {\n      return this.state[storyId] || getInitialState();\n    }\n    setState(storyId, update) {\n      if (storyId) {\n        let state = this.getState(storyId),\n          patch = typeof update == \"function\" ? update(state) : update;\n        this.state = {\n          ...this.state,\n          [storyId]: {\n            ...state,\n            ...patch\n          }\n        }, this.updateParentWindowState();\n      }\n    }\n    cleanup() {\n      this.state = Object.entries(this.state).reduce((acc, [storyId, state]) => {\n        let retainedState = getRetainedState(state);\n        return retainedState && (acc[storyId] = Object.assign(getInitialState(), retainedState)), acc;\n      }, {});\n      let payload = {\n        controlStates: {\n          detached: this.detached,\n          start: !1,\n          back: !1,\n          goto: !1,\n          next: !1,\n          end: !1\n        },\n        logItems: []\n      };\n      this.channel?.emit(EVENTS.SYNC, payload), this.updateParentWindowState();\n    }\n    getLog(storyId) {\n      let {\n          calls,\n          shadowCalls\n        } = this.getState(storyId),\n        merged = [...shadowCalls];\n      calls.forEach((call, index) => {\n        merged[index] = call;\n      });\n      let seen = /* @__PURE__ */new Set();\n      return merged.reduceRight((acc, call) => (call.args.forEach(arg => {\n        arg?.__callId__ && seen.add(arg.__callId__);\n      }), call.path.forEach(node => {\n        node.__callId__ && seen.add(node.__callId__);\n      }), (call.interceptable || call.exception) && !seen.has(call.id) && (acc.unshift({\n        callId: call.id,\n        status: call.status,\n        ancestors: call.ancestors\n      }), seen.add(call.id)), acc), []);\n    }\n    // Traverses the object structure to recursively patch all function properties.\n    // Returns the original object, or a new object with the same constructor,\n    // depending on whether it should mutate.\n    instrument(obj, options, depth = 0) {\n      if (!isInstrumentable(obj)) return obj;\n      let {\n          mutate = !1,\n          path = []\n        } = options,\n        keys = options.getKeys ? options.getKeys(obj, depth) : Object.keys(obj);\n      return depth += 1, keys.reduce((acc, key) => {\n        let descriptor = getPropertyDescriptor(obj, key);\n        if (typeof descriptor?.get == \"function\") {\n          if (descriptor.configurable) {\n            let getter = () => descriptor?.get?.bind(obj)?.();\n            Object.defineProperty(acc, key, {\n              get: () => this.instrument(getter(), {\n                ...options,\n                path: path.concat(key)\n              }, depth)\n            });\n          }\n          return acc;\n        }\n        let value = obj[key];\n        return typeof value != \"function\" ? (acc[key] = this.instrument(value, {\n          ...options,\n          path: path.concat(key)\n        }, depth), acc) : \"__originalFn__\" in value && typeof value.__originalFn__ == \"function\" ? (acc[key] = value, acc) : (acc[key] = (...args) => this.track(key, value, obj, args, options), acc[key].__originalFn__ = value, Object.defineProperty(acc[key], \"name\", {\n          value: key,\n          writable: !1\n        }), Object.keys(value).length > 0 && Object.assign(acc[key], this.instrument({\n          ...value\n        }, {\n          ...options,\n          path: path.concat(key)\n        }, depth)), acc);\n      }, mutate ? obj : construct(obj));\n    }\n    // Monkey patch an object method to record calls.\n    // Returns a function that invokes the original function, records the invocation (\"call\") and\n    // returns the original result.\n    track(method, fn, object, args, options) {\n      let storyId = args?.[0]?.__storyId__ || global.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId,\n        {\n          cursor,\n          ancestors\n        } = this.getState(storyId);\n      this.setState(storyId, {\n        cursor: cursor + 1\n      });\n      let id = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`,\n        {\n          path = [],\n          intercept = !1,\n          retain = !1\n        } = options,\n        interceptable = typeof intercept == \"function\" ? intercept(method, path) : intercept,\n        call = {\n          id,\n          cursor,\n          storyId,\n          ancestors,\n          path,\n          method,\n          args,\n          interceptable,\n          retain\n        },\n        result = (interceptable && !ancestors.length ? this.intercept : this.invoke).call(this, fn, object, call, options);\n      return this.instrument(result, {\n        ...options,\n        mutate: !0,\n        path: [{\n          __callId__: call.id\n        }]\n      });\n    }\n    intercept(fn, object, call, options) {\n      let {\n          chainedCallIds,\n          isDebugging,\n          playUntil\n        } = this.getState(call.storyId),\n        isChainedUpon = chainedCallIds.has(call.id);\n      return !isDebugging || isChainedUpon || playUntil ? (playUntil === call.id && this.setState(call.storyId, {\n        playUntil: void 0\n      }), this.invoke(fn, object, call, options)) : new Promise(resolve => {\n        this.setState(call.storyId, ({\n          resolvers\n        }) => ({\n          isLocked: !1,\n          resolvers: {\n            ...resolvers,\n            [call.id]: resolve\n          }\n        }));\n      }).then(() => (this.setState(call.storyId, state => {\n        let {\n          [call.id]: _,\n          ...resolvers\n        } = state.resolvers;\n        return {\n          isLocked: !0,\n          resolvers\n        };\n      }), this.invoke(fn, object, call, options)));\n    }\n    invoke(fn, object, call, options) {\n      let {\n          callRefsByResult,\n          renderPhase\n        } = this.getState(call.storyId),\n        maximumDepth = 25,\n        serializeValues = (value, depth, seen) => {\n          if (seen.includes(value)) return \"[Circular]\";\n          if (seen = [...seen, value], depth > maximumDepth) return \"...\";\n          if (callRefsByResult.has(value)) return callRefsByResult.get(value);\n          if (value instanceof Array) return value.map(it => serializeValues(it, ++depth, seen));\n          if (value instanceof Date) return {\n            __date__: {\n              value: value.toISOString()\n            }\n          };\n          if (value instanceof Error) {\n            let {\n              name,\n              message,\n              stack\n            } = value;\n            return {\n              __error__: {\n                name,\n                message,\n                stack\n              }\n            };\n          }\n          if (value instanceof RegExp) {\n            let {\n              flags,\n              source\n            } = value;\n            return {\n              __regexp__: {\n                flags,\n                source\n              }\n            };\n          }\n          if (value instanceof global.window?.HTMLElement) {\n            let {\n                prefix,\n                localName,\n                id,\n                classList,\n                innerText\n              } = value,\n              classNames = Array.from(classList);\n            return {\n              __element__: {\n                prefix,\n                localName,\n                id,\n                classNames,\n                innerText\n              }\n            };\n          }\n          return typeof value == \"function\" ? {\n            __function__: {\n              name: \"getMockName\" in value ? value.getMockName() : value.name\n            }\n          } : typeof value == \"symbol\" ? {\n            __symbol__: {\n              description: value.description\n            }\n          } : typeof value == \"object\" && value?.constructor?.name && value?.constructor?.name !== \"Object\" ? {\n            __class__: {\n              name: value.constructor.name\n            }\n          } : Object.prototype.toString.call(value) === \"[object Object]\" ? Object.fromEntries(Object.entries(value).map(([key, val]) => [key, serializeValues(val, ++depth, seen)])) : value;\n        },\n        info = {\n          ...call,\n          args: call.args.map(arg => serializeValues(arg, 0, []))\n        };\n      call.path.forEach(ref => {\n        ref?.__callId__ && this.setState(call.storyId, ({\n          chainedCallIds\n        }) => ({\n          chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__))\n        }));\n      });\n      let handleException = e => {\n        if (e instanceof Error) {\n          let {\n              name,\n              message,\n              stack,\n              callId = call.id\n            } = e,\n            {\n              showDiff = void 0,\n              diff = void 0,\n              actual = void 0,\n              expected = void 0\n            } = e.name === \"AssertionError\" ? processError(e) : e,\n            exception = {\n              name,\n              message,\n              stack,\n              callId,\n              showDiff,\n              diff,\n              actual,\n              expected\n            };\n          if (this.update({\n            ...info,\n            status: \"error\" /* ERROR */,\n            exception\n          }), this.setState(call.storyId, state => ({\n            callRefsByResult: new Map([...Array.from(state.callRefsByResult.entries()), [e, {\n              __callId__: call.id,\n              retain: call.retain\n            }]])\n          })), call.ancestors?.length) throw Object.prototype.hasOwnProperty.call(e, \"callId\") || Object.defineProperty(e, \"callId\", {\n            value: call.id\n          }), e;\n        }\n        throw e;\n      };\n      try {\n        if (renderPhase === \"played\" && !call.retain) throw alreadyCompletedException;\n        let finalArgs = (options.getArgs ? options.getArgs(call, this.getState(call.storyId)) : call.args).map(arg => typeof arg != \"function\" || isClass(arg) || Object.keys(arg).length ? arg : (...args) => {\n            let {\n              cursor,\n              ancestors\n            } = this.getState(call.storyId);\n            this.setState(call.storyId, {\n              cursor: 0,\n              ancestors: [...ancestors, call.id]\n            });\n            let restore = () => this.setState(call.storyId, {\n                cursor,\n                ancestors\n              }),\n              willRestore = !1;\n            try {\n              let res = arg(...args);\n              return res instanceof Promise ? (willRestore = !0, res.finally(restore)) : res;\n            } finally {\n              willRestore || restore();\n            }\n          }),\n          result = fn.apply(object, finalArgs);\n        return result && [\"object\", \"function\", \"symbol\"].includes(typeof result) && this.setState(call.storyId, state => ({\n          callRefsByResult: new Map([...Array.from(state.callRefsByResult.entries()), [result, {\n            __callId__: call.id,\n            retain: call.retain\n          }]])\n        })), this.update({\n          ...info,\n          status: result instanceof Promise ? \"active\" /* ACTIVE */ : \"done\" /* DONE */\n        }), result instanceof Promise ? result.then(value => (this.update({\n          ...info,\n          status: \"done\" /* DONE */\n        }), value), handleException) : result;\n      } catch (e) {\n        return handleException(e);\n      }\n    }\n    // Sends the call info to the manager and synchronizes the log.\n    update(call) {\n      this.channel?.emit(EVENTS.CALL, call), this.setState(call.storyId, ({\n        calls\n      }) => {\n        let callsById = calls.concat(call).reduce((a, c) => Object.assign(a, {\n          [c.id]: c\n        }), {});\n        return {\n          // Calls are sorted to ensure parent calls always come before calls in their callback.\n          calls: Object.values(callsById).sort((a, b) => a.id.localeCompare(b.id, void 0, {\n            numeric: !0\n          }))\n        };\n      }), this.sync(call.storyId);\n    }\n    // Builds a log of interceptable calls and control states and sends it to the manager.\n    // Uses a 0ms debounce because this might get called many times in one tick.\n    sync(storyId) {\n      let synchronize = () => {\n        let {\n            isLocked,\n            isPlaying\n          } = this.getState(storyId),\n          logItems = this.getLog(storyId),\n          pausedAt = logItems.filter(({\n            ancestors\n          }) => !ancestors.length).find(item => item.status === \"waiting\" /* WAITING */)?.callId,\n          hasActive = logItems.some(item => item.status === \"active\" /* ACTIVE */);\n        if (this.detached || isLocked || hasActive || logItems.length === 0) {\n          let payload2 = {\n            controlStates: {\n              detached: this.detached,\n              start: !1,\n              back: !1,\n              goto: !1,\n              next: !1,\n              end: !1\n            },\n            logItems\n          };\n          this.channel?.emit(EVENTS.SYNC, payload2);\n          return;\n        }\n        let hasPrevious = logItems.some(item => item.status === \"done\" /* DONE */ || item.status === \"error\" /* ERROR */),\n          payload = {\n            controlStates: {\n              detached: this.detached,\n              start: hasPrevious,\n              back: hasPrevious,\n              goto: !0,\n              next: isPlaying,\n              end: isPlaying\n            },\n            logItems,\n            pausedAt\n          };\n        this.channel?.emit(EVENTS.SYNC, payload);\n      };\n      this.setState(storyId, ({\n        syncTimeout\n      }) => (clearTimeout(syncTimeout), {\n        syncTimeout: setTimeout(synchronize, 0)\n      }));\n    }\n  };\nfunction instrument(obj, options = {}) {\n  try {\n    let forceInstrument = !1,\n      skipInstrument = !1;\n    return global.window?.location?.search?.includes(\"instrument=true\") ? forceInstrument = !0 : global.window?.location?.search?.includes(\"instrument=false\") && (skipInstrument = !0), global.window?.parent === global.window && !forceInstrument || skipInstrument ? obj : (global.window && !global.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ && (global.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter()), (global.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(obj, options));\n  } catch (e) {\n    return once.warn(e), obj;\n  }\n}\nfunction getPropertyDescriptor(obj, propName) {\n  let target = obj;\n  for (; target != null;) {\n    let descriptor = Object.getOwnPropertyDescriptor(target, propName);\n    if (descriptor) return descriptor;\n    target = Object.getPrototypeOf(target);\n  }\n}\nfunction isClass(obj) {\n  if (typeof obj != \"function\") return !1;\n  let descriptor = Object.getOwnPropertyDescriptor(obj, \"prototype\");\n  return descriptor ? !descriptor.writable : !1;\n}\nexport { CallStates, EVENTS, instrument };","map":{"version":3,"names":["CallStates","EVENTS","processError","once","FORCE_REMOUNT","SET_CURRENT_STORY","STORY_RENDER_PHASE_CHANGED","global","addons","globalThis","__STORYBOOK_ADDONS_PREVIEW","alreadyCompletedException","Error","isObject","o","Object","prototype","toString","call","isModule","isInstrumentable","constructor","proto","construct","obj","getInitialState","renderPhase","isDebugging","isPlaying","isLocked","cursor","calls","shadowCalls","callRefsByResult","Map","chainedCallIds","Set","ancestors","playUntil","resolvers","syncTimeout","getRetainedState","state","filter","retain","length","Array","from","entries","ref","Instrumenter","detached","initialized","loadParentWindowState","window","parent","__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__","updateParentWindowState","resetState","storyId","getState","setState","sync","start","channel","map","status","log","getLog","firstRowIndex","findIndex","id","callId","slice","interceptable","emit","back","last","reduceRight","res","item","index","goto","find","shadowCall","values","nextId","c","forEach","resolve","next","end","renderPhaseChanged","newPhase","ready","then","getChannel","on","cleanup","START","BACK","GOTO","NEXT","END","update","patch","reduce","acc","retainedState","assign","payload","controlStates","logItems","SYNC","merged","seen","args","arg","__callId__","add","path","node","exception","has","unshift","instrument","options","depth","mutate","keys","getKeys","key","descriptor","getPropertyDescriptor","get","configurable","getter","bind","defineProperty","concat","value","__originalFn__","track","writable","method","fn","object","__storyId__","__STORYBOOK_PREVIEW__","selectionStore","selection","intercept","result","invoke","isChainedUpon","Promise","_","maximumDepth","serializeValues","includes","it","Date","__date__","toISOString","name","message","stack","__error__","RegExp","flags","source","__regexp__","HTMLElement","prefix","localName","classList","innerText","classNames","__element__","__function__","getMockName","__symbol__","description","__class__","fromEntries","val","info","handleException","e","showDiff","diff","actual","expected","hasOwnProperty","finalArgs","getArgs","isClass","restore","willRestore","finally","apply","CALL","callsById","a","sort","b","localeCompare","numeric","synchronize","pausedAt","hasActive","some","payload2","hasPrevious","clearTimeout","setTimeout","forceInstrument","skipInstrument","location","search","__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__","warn","propName","target","getOwnPropertyDescriptor","getPrototypeOf"],"sources":["/Users/pea/Desktop/work/my-workspace/node_modules/storybook/dist/instrumenter/index.js"],"sourcesContent":["import {\n  CallStates,\n  EVENTS\n} from \"../_browser-chunks/chunk-ZUWEVLDX.js\";\nimport {\n  processError\n} from \"../_browser-chunks/chunk-RP5RXKFU.js\";\nimport \"../_browser-chunks/chunk-A242L54C.js\";\n\n// src/instrumenter/instrumenter.ts\nimport { once } from \"storybook/internal/client-logger\";\nimport {\n  FORCE_REMOUNT,\n  SET_CURRENT_STORY,\n  STORY_RENDER_PHASE_CHANGED\n} from \"storybook/internal/core-events\";\nimport { global } from \"@storybook/global\";\n\n// src/instrumenter/preview-api.ts\nvar addons = globalThis.__STORYBOOK_ADDONS_PREVIEW;\n\n// src/instrumenter/instrumenter.ts\nvar alreadyCompletedException = new Error(\n  \"This function ran after the play function completed. Did you forget to `await` it?\"\n), isObject = (o) => Object.prototype.toString.call(o) === \"[object Object]\", isModule = (o) => Object.prototype.toString.call(o) === \"[object Module]\", isInstrumentable = (o) => {\n  if (!isObject(o) && !isModule(o))\n    return !1;\n  if (o.constructor === void 0)\n    return !0;\n  let proto = o.constructor.prototype;\n  return !!isObject(proto);\n}, construct = (obj) => {\n  try {\n    return new obj.constructor();\n  } catch {\n    return {};\n  }\n}, getInitialState = () => ({\n  renderPhase: \"preparing\",\n  isDebugging: !1,\n  isPlaying: !1,\n  isLocked: !1,\n  cursor: 0,\n  calls: [],\n  shadowCalls: [],\n  callRefsByResult: /* @__PURE__ */ new Map(),\n  chainedCallIds: /* @__PURE__ */ new Set(),\n  ancestors: [],\n  playUntil: void 0,\n  resolvers: {},\n  syncTimeout: void 0\n}), getRetainedState = (state, isDebugging = !1) => {\n  let calls = (isDebugging ? state.shadowCalls : state.calls).filter((call) => call.retain);\n  if (!calls.length)\n    return;\n  let callRefsByResult = new Map(\n    Array.from(state.callRefsByResult.entries()).filter(([, ref]) => ref.retain)\n  );\n  return { cursor: calls.length, calls, callRefsByResult };\n}, Instrumenter = class {\n  constructor() {\n    this.detached = !1;\n    this.initialized = !1;\n    // State is tracked per story to deal with multiple stories on the same canvas (i.e. docs mode)\n    this.state = {};\n    this.loadParentWindowState = () => {\n      try {\n        this.state = global.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};\n      } catch {\n        this.detached = !0;\n      }\n    };\n    this.updateParentWindowState = () => {\n      try {\n        global.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;\n      } catch {\n        this.detached = !0;\n      }\n    };\n    this.loadParentWindowState();\n    let resetState = ({\n      storyId,\n      renderPhase,\n      isPlaying = !0,\n      isDebugging = !1\n    }) => {\n      let state = this.getState(storyId);\n      this.setState(storyId, {\n        ...getInitialState(),\n        ...getRetainedState(state, isDebugging),\n        renderPhase: renderPhase || state.renderPhase,\n        shadowCalls: isDebugging ? state.shadowCalls : [],\n        chainedCallIds: isDebugging ? state.chainedCallIds : /* @__PURE__ */ new Set(),\n        playUntil: isDebugging ? state.playUntil : void 0,\n        isPlaying,\n        isDebugging\n      }), this.sync(storyId);\n    }, start = (channel) => ({ storyId, playUntil }) => {\n      this.getState(storyId).isDebugging || this.setState(storyId, ({ calls }) => ({\n        calls: [],\n        shadowCalls: calls.map((call) => ({ ...call, status: \"waiting\" /* WAITING */ })),\n        isDebugging: !0\n      }));\n      let log = this.getLog(storyId);\n      this.setState(storyId, ({ shadowCalls }) => {\n        if (playUntil || !log.length)\n          return { playUntil };\n        let firstRowIndex = shadowCalls.findIndex((call) => call.id === log[0].callId);\n        return {\n          playUntil: shadowCalls.slice(0, firstRowIndex).filter((call) => call.interceptable && !call.ancestors?.length).slice(-1)[0]?.id\n        };\n      }), channel.emit(FORCE_REMOUNT, { storyId, isDebugging: !0 });\n    }, back = (channel) => ({ storyId }) => {\n      let log = this.getLog(storyId).filter((call) => !call.ancestors?.length), last = log.reduceRight((res, item, index) => res >= 0 || item.status === \"waiting\" /* WAITING */ ? res : index, -1);\n      start(channel)({ storyId, playUntil: log[last - 1]?.callId });\n    }, goto = (channel) => ({ storyId, callId }) => {\n      let { calls, shadowCalls, resolvers } = this.getState(storyId), call = calls.find(({ id }) => id === callId), shadowCall = shadowCalls.find(({ id }) => id === callId);\n      if (!call && shadowCall && Object.values(resolvers).length > 0) {\n        let nextId = this.getLog(storyId).find((c) => c.status === \"waiting\" /* WAITING */)?.callId;\n        shadowCall.id !== nextId && this.setState(storyId, { playUntil: shadowCall.id }), Object.values(resolvers).forEach((resolve) => resolve());\n      } else\n        start(channel)({ storyId, playUntil: callId });\n    }, next = (channel) => ({ storyId }) => {\n      let { resolvers } = this.getState(storyId);\n      if (Object.values(resolvers).length > 0)\n        Object.values(resolvers).forEach((resolve) => resolve());\n      else {\n        let nextId = this.getLog(storyId).find((c) => c.status === \"waiting\" /* WAITING */)?.callId;\n        nextId ? start(channel)({ storyId, playUntil: nextId }) : end({ storyId });\n      }\n    }, end = ({ storyId }) => {\n      this.setState(storyId, { playUntil: void 0, isDebugging: !1 }), Object.values(this.getState(storyId).resolvers).forEach((resolve) => resolve());\n    }, renderPhaseChanged = ({\n      storyId,\n      newPhase\n    }) => {\n      let { isDebugging } = this.getState(storyId);\n      if (newPhase === \"preparing\" && isDebugging)\n        return resetState({ storyId, renderPhase: newPhase, isDebugging });\n      if (newPhase === \"playing\")\n        return resetState({ storyId, renderPhase: newPhase, isDebugging });\n      newPhase === \"played\" ? this.setState(storyId, {\n        renderPhase: newPhase,\n        isLocked: !1,\n        isPlaying: !1,\n        isDebugging: !1\n      }) : newPhase === \"errored\" ? this.setState(storyId, {\n        renderPhase: newPhase,\n        isLocked: !1,\n        isPlaying: !1\n      }) : newPhase === \"aborted\" ? this.setState(storyId, {\n        renderPhase: newPhase,\n        isLocked: !0,\n        isPlaying: !1\n      }) : this.setState(storyId, {\n        renderPhase: newPhase\n      }), this.sync(storyId);\n    };\n    addons && addons.ready().then(() => {\n      this.channel = addons.getChannel(), this.channel.on(FORCE_REMOUNT, resetState), this.channel.on(STORY_RENDER_PHASE_CHANGED, renderPhaseChanged), this.channel.on(SET_CURRENT_STORY, () => {\n        this.initialized ? this.cleanup() : this.initialized = !0;\n      }), this.channel.on(EVENTS.START, start(this.channel)), this.channel.on(EVENTS.BACK, back(this.channel)), this.channel.on(EVENTS.GOTO, goto(this.channel)), this.channel.on(EVENTS.NEXT, next(this.channel)), this.channel.on(EVENTS.END, end);\n    });\n  }\n  getState(storyId) {\n    return this.state[storyId] || getInitialState();\n  }\n  setState(storyId, update) {\n    if (storyId) {\n      let state = this.getState(storyId), patch = typeof update == \"function\" ? update(state) : update;\n      this.state = { ...this.state, [storyId]: { ...state, ...patch } }, this.updateParentWindowState();\n    }\n  }\n  cleanup() {\n    this.state = Object.entries(this.state).reduce(\n      (acc, [storyId, state]) => {\n        let retainedState = getRetainedState(state);\n        return retainedState && (acc[storyId] = Object.assign(getInitialState(), retainedState)), acc;\n      },\n      {}\n    );\n    let payload = { controlStates: {\n      detached: this.detached,\n      start: !1,\n      back: !1,\n      goto: !1,\n      next: !1,\n      end: !1\n    }, logItems: [] };\n    this.channel?.emit(EVENTS.SYNC, payload), this.updateParentWindowState();\n  }\n  getLog(storyId) {\n    let { calls, shadowCalls } = this.getState(storyId), merged = [...shadowCalls];\n    calls.forEach((call, index) => {\n      merged[index] = call;\n    });\n    let seen = /* @__PURE__ */ new Set();\n    return merged.reduceRight((acc, call) => (call.args.forEach((arg) => {\n      arg?.__callId__ && seen.add(arg.__callId__);\n    }), call.path.forEach((node) => {\n      node.__callId__ && seen.add(node.__callId__);\n    }), (call.interceptable || call.exception) && !seen.has(call.id) && (acc.unshift({ callId: call.id, status: call.status, ancestors: call.ancestors }), seen.add(call.id)), acc), []);\n  }\n  // Traverses the object structure to recursively patch all function properties.\n  // Returns the original object, or a new object with the same constructor,\n  // depending on whether it should mutate.\n  instrument(obj, options, depth = 0) {\n    if (!isInstrumentable(obj))\n      return obj;\n    let { mutate = !1, path = [] } = options, keys = options.getKeys ? options.getKeys(obj, depth) : Object.keys(obj);\n    return depth += 1, keys.reduce(\n      (acc, key) => {\n        let descriptor = getPropertyDescriptor(obj, key);\n        if (typeof descriptor?.get == \"function\") {\n          if (descriptor.configurable) {\n            let getter = () => descriptor?.get?.bind(obj)?.();\n            Object.defineProperty(acc, key, {\n              get: () => this.instrument(getter(), { ...options, path: path.concat(key) }, depth)\n            });\n          }\n          return acc;\n        }\n        let value = obj[key];\n        return typeof value != \"function\" ? (acc[key] = this.instrument(value, { ...options, path: path.concat(key) }, depth), acc) : \"__originalFn__\" in value && typeof value.__originalFn__ == \"function\" ? (acc[key] = value, acc) : (acc[key] = (...args) => this.track(key, value, obj, args, options), acc[key].__originalFn__ = value, Object.defineProperty(acc[key], \"name\", { value: key, writable: !1 }), Object.keys(value).length > 0 && Object.assign(\n          acc[key],\n          this.instrument({ ...value }, { ...options, path: path.concat(key) }, depth)\n        ), acc);\n      },\n      mutate ? obj : construct(obj)\n    );\n  }\n  // Monkey patch an object method to record calls.\n  // Returns a function that invokes the original function, records the invocation (\"call\") and\n  // returns the original result.\n  track(method, fn, object, args, options) {\n    let storyId = args?.[0]?.__storyId__ || global.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId, { cursor, ancestors } = this.getState(storyId);\n    this.setState(storyId, { cursor: cursor + 1 });\n    let id = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`, { path = [], intercept = !1, retain = !1 } = options, interceptable = typeof intercept == \"function\" ? intercept(method, path) : intercept, call = { id, cursor, storyId, ancestors, path, method, args, interceptable, retain }, result = (interceptable && !ancestors.length ? this.intercept : this.invoke).call(this, fn, object, call, options);\n    return this.instrument(result, { ...options, mutate: !0, path: [{ __callId__: call.id }] });\n  }\n  intercept(fn, object, call, options) {\n    let { chainedCallIds, isDebugging, playUntil } = this.getState(call.storyId), isChainedUpon = chainedCallIds.has(call.id);\n    return !isDebugging || isChainedUpon || playUntil ? (playUntil === call.id && this.setState(call.storyId, { playUntil: void 0 }), this.invoke(fn, object, call, options)) : new Promise((resolve) => {\n      this.setState(call.storyId, ({ resolvers }) => ({\n        isLocked: !1,\n        resolvers: { ...resolvers, [call.id]: resolve }\n      }));\n    }).then(() => (this.setState(call.storyId, (state) => {\n      let { [call.id]: _, ...resolvers } = state.resolvers;\n      return { isLocked: !0, resolvers };\n    }), this.invoke(fn, object, call, options)));\n  }\n  invoke(fn, object, call, options) {\n    let { callRefsByResult, renderPhase } = this.getState(call.storyId), maximumDepth = 25, serializeValues = (value, depth, seen) => {\n      if (seen.includes(value))\n        return \"[Circular]\";\n      if (seen = [...seen, value], depth > maximumDepth)\n        return \"...\";\n      if (callRefsByResult.has(value))\n        return callRefsByResult.get(value);\n      if (value instanceof Array)\n        return value.map((it) => serializeValues(it, ++depth, seen));\n      if (value instanceof Date)\n        return { __date__: { value: value.toISOString() } };\n      if (value instanceof Error) {\n        let { name, message, stack } = value;\n        return { __error__: { name, message, stack } };\n      }\n      if (value instanceof RegExp) {\n        let { flags, source } = value;\n        return { __regexp__: { flags, source } };\n      }\n      if (value instanceof global.window?.HTMLElement) {\n        let { prefix, localName, id, classList, innerText } = value, classNames = Array.from(classList);\n        return { __element__: { prefix, localName, id, classNames, innerText } };\n      }\n      return typeof value == \"function\" ? {\n        __function__: { name: \"getMockName\" in value ? value.getMockName() : value.name }\n      } : typeof value == \"symbol\" ? { __symbol__: { description: value.description } } : typeof value == \"object\" && value?.constructor?.name && value?.constructor?.name !== \"Object\" ? { __class__: { name: value.constructor.name } } : Object.prototype.toString.call(value) === \"[object Object]\" ? Object.fromEntries(\n        Object.entries(value).map(([key, val]) => [key, serializeValues(val, ++depth, seen)])\n      ) : value;\n    }, info = {\n      ...call,\n      args: call.args.map((arg) => serializeValues(arg, 0, []))\n    };\n    call.path.forEach((ref) => {\n      ref?.__callId__ && this.setState(call.storyId, ({ chainedCallIds }) => ({\n        chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__))\n      }));\n    });\n    let handleException = (e) => {\n      if (e instanceof Error) {\n        let { name, message, stack, callId = call.id } = e, {\n          showDiff = void 0,\n          diff = void 0,\n          actual = void 0,\n          expected = void 0\n        } = e.name === \"AssertionError\" ? processError(e) : e, exception = { name, message, stack, callId, showDiff, diff, actual, expected };\n        if (this.update({ ...info, status: \"error\" /* ERROR */, exception }), this.setState(call.storyId, (state) => ({\n          callRefsByResult: new Map([\n            ...Array.from(state.callRefsByResult.entries()),\n            [e, { __callId__: call.id, retain: call.retain }]\n          ])\n        })), call.ancestors?.length)\n          throw Object.prototype.hasOwnProperty.call(e, \"callId\") || Object.defineProperty(e, \"callId\", { value: call.id }), e;\n      }\n      throw e;\n    };\n    try {\n      if (renderPhase === \"played\" && !call.retain)\n        throw alreadyCompletedException;\n      let finalArgs = (options.getArgs ? options.getArgs(call, this.getState(call.storyId)) : call.args).map((arg) => typeof arg != \"function\" || isClass(arg) || Object.keys(arg).length ? arg : (...args) => {\n        let { cursor, ancestors } = this.getState(call.storyId);\n        this.setState(call.storyId, { cursor: 0, ancestors: [...ancestors, call.id] });\n        let restore = () => this.setState(call.storyId, { cursor, ancestors }), willRestore = !1;\n        try {\n          let res = arg(...args);\n          return res instanceof Promise ? (willRestore = !0, res.finally(restore)) : res;\n        } finally {\n          willRestore || restore();\n        }\n      }), result = fn.apply(object, finalArgs);\n      return result && [\"object\", \"function\", \"symbol\"].includes(typeof result) && this.setState(call.storyId, (state) => ({\n        callRefsByResult: new Map([\n          ...Array.from(state.callRefsByResult.entries()),\n          [result, { __callId__: call.id, retain: call.retain }]\n        ])\n      })), this.update({\n        ...info,\n        status: result instanceof Promise ? \"active\" /* ACTIVE */ : \"done\" /* DONE */\n      }), result instanceof Promise ? result.then((value) => (this.update({ ...info, status: \"done\" /* DONE */ }), value), handleException) : result;\n    } catch (e) {\n      return handleException(e);\n    }\n  }\n  // Sends the call info to the manager and synchronizes the log.\n  update(call) {\n    this.channel?.emit(EVENTS.CALL, call), this.setState(call.storyId, ({ calls }) => {\n      let callsById = calls.concat(call).reduce((a, c) => Object.assign(a, { [c.id]: c }), {});\n      return {\n        // Calls are sorted to ensure parent calls always come before calls in their callback.\n        calls: Object.values(callsById).sort(\n          (a, b) => a.id.localeCompare(b.id, void 0, { numeric: !0 })\n        )\n      };\n    }), this.sync(call.storyId);\n  }\n  // Builds a log of interceptable calls and control states and sends it to the manager.\n  // Uses a 0ms debounce because this might get called many times in one tick.\n  sync(storyId) {\n    let synchronize = () => {\n      let { isLocked, isPlaying } = this.getState(storyId), logItems = this.getLog(storyId), pausedAt = logItems.filter(({ ancestors }) => !ancestors.length).find((item) => item.status === \"waiting\" /* WAITING */)?.callId, hasActive = logItems.some((item) => item.status === \"active\" /* ACTIVE */);\n      if (this.detached || isLocked || hasActive || logItems.length === 0) {\n        let payload2 = { controlStates: {\n          detached: this.detached,\n          start: !1,\n          back: !1,\n          goto: !1,\n          next: !1,\n          end: !1\n        }, logItems };\n        this.channel?.emit(EVENTS.SYNC, payload2);\n        return;\n      }\n      let hasPrevious = logItems.some(\n        (item) => item.status === \"done\" /* DONE */ || item.status === \"error\" /* ERROR */\n      ), payload = { controlStates: {\n        detached: this.detached,\n        start: hasPrevious,\n        back: hasPrevious,\n        goto: !0,\n        next: isPlaying,\n        end: isPlaying\n      }, logItems, pausedAt };\n      this.channel?.emit(EVENTS.SYNC, payload);\n    };\n    this.setState(storyId, ({ syncTimeout }) => (clearTimeout(syncTimeout), { syncTimeout: setTimeout(synchronize, 0) }));\n  }\n};\nfunction instrument(obj, options = {}) {\n  try {\n    let forceInstrument = !1, skipInstrument = !1;\n    return global.window?.location?.search?.includes(\"instrument=true\") ? forceInstrument = !0 : global.window?.location?.search?.includes(\"instrument=false\") && (skipInstrument = !0), global.window?.parent === global.window && !forceInstrument || skipInstrument ? obj : (global.window && !global.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ && (global.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter()), (global.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(obj, options));\n  } catch (e) {\n    return once.warn(e), obj;\n  }\n}\nfunction getPropertyDescriptor(obj, propName) {\n  let target = obj;\n  for (; target != null; ) {\n    let descriptor = Object.getOwnPropertyDescriptor(target, propName);\n    if (descriptor)\n      return descriptor;\n    target = Object.getPrototypeOf(target);\n  }\n}\nfunction isClass(obj) {\n  if (typeof obj != \"function\")\n    return !1;\n  let descriptor = Object.getOwnPropertyDescriptor(obj, \"prototype\");\n  return descriptor ? !descriptor.writable : !1;\n}\nexport {\n  CallStates,\n  EVENTS,\n  instrument\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}